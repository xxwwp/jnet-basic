<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 3.0.2"/><title data-react-helmet="true"></title><link data-react-helmet="true" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism-tomorrow.css"/><link as="script" rel="preload" href="/jnet-basic/webpack-runtime-c0b04000bf61299ee581.js"/><link as="script" rel="preload" href="/jnet-basic/framework-e8e53ba50a7a1b0850f7.js"/><link as="script" rel="preload" href="/jnet-basic/app-d216605bc40c2cb179d1.js"/><link as="script" rel="preload" href="/jnet-basic/1512ff2dbf77859a0dcbee24710e2018e282937f-369ee37846485c1e14f7.js"/><link as="script" rel="preload" href="/jnet-basic/component---src-templates-docs-tsx-58d24a1592ae4305da8e.js"/><link as="fetch" rel="preload" href="/jnet-basic/page-data/js/对象原型/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/jnet-basic/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css-global b48ifx">body{margin:0;}html,body{overflow-x:hidden;}</style><style data-emotion="css-global 1vo6k5w">body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";color:#303133;}</style><style data-emotion="css zdq125">.css-zdq125{position:fixed;left:0;top:0;bottom:0;-webkit-transition:-webkit-transform 0.3s,opacity 0.3s;transition:transform 0.3s,opacity 0.3s;overflow:hidden;z-index:10;}@media screen and (min-width: 1200px){.css-zdq125:hover{overflow:auto;overflow:overlay;}}@media screen and (max-width: 1200px){.css-zdq125{opacity:0;-webkit-transform:translateX(-100%);-moz-transform:translateX(-100%);-ms-transform:translateX(-100%);transform:translateX(-100%);}.css-zdq125.active{opacity:1;-webkit-transform:translateX(0);-moz-transform:translateX(0);-ms-transform:translateX(0);transform:translateX(0);overflow:auto;overflow:overlay;}.css-zdq125 nav{width:100vw;}}</style><aside class=" css-zdq125"><style data-emotion="css k4cgyt">.css-k4cgyt{width:200px;overflow:hidden;padding:10px 0px 50px;border-right:4px double rgba(0, 0, 0, 0.1);min-height:100%;background:#fff;}.css-k4cgyt .title{text-align:center;}.css-k4cgyt .title a{line-height:40px;color:#c0c0c0;-webkit-text-decoration:none;text-decoration:none;font-size:1.5em;}</style><nav class="css-k4cgyt"><div class="title"><a href="/jnet-basic/">JNet Basic</a></div><style data-emotion="css smzts4">.css-smzts4 ol{list-style:none;padding-left:20px;margin:0;}.css-smzts4 ol ol{padding-left:10px;}.css-smzts4 ol li{line-height:30px;margin:0;}.css-smzts4 ol a{color:#555;-webkit-text-decoration:none;text-decoration:none;line-height:30px;}.css-smzts4 ol a:hover,.css-smzts4 ol a.current{color:#999;}</style><div class="css-smzts4"><ol><li><style data-emotion="css opu5s9">.css-opu5s9.active{color:#999;}</style><a class="css-opu5s9" href="/jnet-basic/课程介绍">课程介绍</a></li><li><span>html</span><ol><li><a class="css-opu5s9" href="/jnet-basic/html/概述">概述</a></li><li><a class="css-opu5s9" href="/jnet-basic/html/基础理论">基础理论</a></li><li><a class="css-opu5s9" href="/jnet-basic/html/头部学习">头部学习</a></li><li><span>元素学习</span><ol><li><a class="css-opu5s9" href="/jnet-basic/html/元素学习/文章相关的元素">文章相关的元素</a></li><li><a class="css-opu5s9" href="/jnet-basic/html/元素学习/超链接与图片">超链接与图片</a></li><li><a class="css-opu5s9" href="/jnet-basic/html/元素学习/无语义元素">无语义元素</a></li><li><a class="css-opu5s9" href="/jnet-basic/html/元素学习/表格">表格</a></li><li><a class="css-opu5s9" href="/jnet-basic/html/元素学习/表单元素">表单元素</a></li></ol></li><li><a class="css-opu5s9" href="/jnet-basic/html/属性">属性</a></li><li><a class="css-opu5s9" href="/jnet-basic/html/补充与结束">补充与结束</a></li></ol></li><li><span>css</span><ol><li><a class="css-opu5s9" href="/jnet-basic/css/概述">概述</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/选择器">选择器</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/核心概念-层叠，继承，优先级">核心概念-层叠，继承，优先级</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/盒模型与文档流">盒模型与文档流</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/文本处理">文本处理</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/表格处理">表格处理</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/背景处理">背景处理</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/杂项">杂项</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/基础布局">基础布局</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/布局进阶">布局进阶</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/常见布局练习">常见布局练习</a></li><li><a class="css-opu5s9" href="/jnet-basic/css/补充与结束">补充与结束</a></li></ol></li><li><span>js</span><ol><li><a class="css-opu5s9" href="/jnet-basic/js/程序引导课">程序引导课</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/基础">基础</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/数据、运算符和表达式">数据、运算符和表达式</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/函数和作用域">函数和作用域</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/引用类型">引用类型</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/流程控制">流程控制</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/类型判断与类型转换">类型判断与类型转换</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/函数深入">函数深入</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/常用_API">常用_API</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/异步编程">异步编程</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/提升">提升</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/闭包">闭包</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/this_关键字">this_关键字</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型">对象原型</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/面向对象">面向对象</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/DOM">DOM</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/事件">事件</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/BOM">BOM</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/渲染与加载">渲染与加载</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/错误处理">错误处理</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/严格模式">严格模式</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/正则字符串">正则字符串</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/网络简述">网络简述</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/杂项">杂项</a></li></ol></li><li><a class="css-opu5s9" href="/jnet-basic/总练习">总练习</a></li><li><a class="css-opu5s9" href="/jnet-basic/课程总结">课程总结</a></li><li><a class="css-opu5s9" href="/jnet-basic/素材">素材</a></li></ol></div></nav></aside><style data-emotion="css 1308utl">.css-1308utl{position:fixed;right:1rem;bottom:1rem;z-index:100;background-color:rgba(82, 122, 253, 0.37);border-radius:50%;padding:10px;border:none;width:20px;height:20px;box-sizing:content-box;-webkit-transition:background-color 0.3s;transition:background-color 0.3s;}@media screen and (min-width: 1200px){.css-1308utl{display:none;}}.css-1308utl svg{width:inherit;height:inherit;-webkit-transition:-webkit-transform 0.3s;transition:transform 0.3s;-webkit-transform:rotateX(0);-moz-transform:rotateX(0);-ms-transform:rotateX(0);transform:rotateX(0);}.css-1308utl.active{background-color:rgba(0, 0, 0, 0.123);}.css-1308utl.active svg{-webkit-transform:rotateX(180deg);-moz-transform:rotateX(180deg);-ms-transform:rotateX(180deg);transform:rotateX(180deg);}</style><button class=" css-1308utl"><svg enable-background="new 0 0 32 32" id="Слой_1" version="1.1" viewBox="0 0 32 32"><path d="M24.285,11.284L16,19.571l-8.285-8.288c-0.395-0.395-1.034-0.395-1.429,0  c-0.394,0.395-0.394,1.035,0,1.43l8.999,9.002l0,0l0,0c0.394,0.395,1.034,0.395,1.428,0l8.999-9.002  c0.394-0.395,0.394-1.036,0-1.431C25.319,10.889,24.679,10.889,24.285,11.284z" fill="#121313" id="Expand_More"></path><g></g><g></g><g></g><g></g><g></g><g></g></svg></button><style data-emotion="css 117dd4v">.css-117dd4v{margin:auto;width:90%;max-width:760px;}.css-117dd4v .article-container{padding:50px 10px;}.css-117dd4v .article-catalog{position:fixed;top:0;left:80%;left:calc(50% + 380px);bottom:0;overflow:hidden;z-index:10;}.css-117dd4v .article-catalog:hover{overflow:auto;overflow:overlay;padding-right:1rem;}@media screen and (max-width: 1200px){.css-117dd4v .article-catalog{display:none;}}</style><main class="css-117dd4v"><aside class="article-catalog"><style data-emotion="css f4f9ae">.css-f4f9ae{padding:20px 0;white-space:nowrap;min-width:120px;box-sizing:content-box;}.css-f4f9ae .title{padding-left:20px;margin-bottom:20px;font-size:1.2em;font-weight:lighter;}</style><nav class="css-f4f9ae"><div class="title">目录</div><style data-emotion="css smzts4">.css-smzts4 ol{list-style:none;padding-left:20px;margin:0;}.css-smzts4 ol ol{padding-left:10px;}.css-smzts4 ol li{line-height:30px;margin:0;}.css-smzts4 ol a{color:#555;-webkit-text-decoration:none;text-decoration:none;line-height:30px;}.css-smzts4 ol a:hover,.css-smzts4 ol a.current{color:#999;}</style><div class="css-smzts4"><ol><li><style data-emotion="css opu5s9">.css-opu5s9.active{color:#999;}</style><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#原型和原型链">原型和原型链</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#基于原型链的属性访问">基于原型链的属性访问</a><ol><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#in 关键字">in 关键字</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#属性屏蔽">属性屏蔽</a></li></ol></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#Object.prototype">Object.prototype</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#原型链的属性遍历">原型链的属性遍历</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#设置对象原型">设置对象原型</a><ol><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#__proto__ &amp; Object.setPrototypeOf">__proto__ &amp; Object.setPrototypeOf</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#通过 Object.create">通过 Object.create</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#new 关键字">new 关键字</a></li></ol></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#instanceof 原型判断">instanceof 原型判断</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#基础数据的原型链">基础数据的原型链</a><ol><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#数组">数组</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#函数">函数</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#包装类">包装类</a></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#原型链小结">原型链小结</a></li></ol></li><li><a class="css-opu5s9" href="/jnet-basic/js/对象原型/#小结">小结</a></li></ol></div></nav></aside><div class="article-container"><style data-emotion="css dsvq8h">.css-dsvq8h{line-height:1.5;}.css-dsvq8h h1,.css-dsvq8h h2,.css-dsvq8h h3,.css-dsvq8h h4,.css-dsvq8h h5,.css-dsvq8h h6{font-weight:500;line-height:1.2;color:#212529;}.css-dsvq8h h1 a,.css-dsvq8h h2 a,.css-dsvq8h h3 a,.css-dsvq8h h4 a,.css-dsvq8h h5 a,.css-dsvq8h h6 a,.css-dsvq8h h1 a:hover,.css-dsvq8h h2 a:hover,.css-dsvq8h h3 a:hover,.css-dsvq8h h4 a:hover,.css-dsvq8h h5 a:hover,.css-dsvq8h h6 a:hover,.css-dsvq8h h1 a:active,.css-dsvq8h h2 a:active,.css-dsvq8h h3 a:active,.css-dsvq8h h4 a:active,.css-dsvq8h h5 a:active,.css-dsvq8h h6 a:active,.css-dsvq8h h1 a:visited,.css-dsvq8h h2 a:visited,.css-dsvq8h h3 a:visited,.css-dsvq8h h4 a:visited,.css-dsvq8h h5 a:visited,.css-dsvq8h h6 a:visited{color:inherit;}.css-dsvq8h h1{font-size:2.5rem;}.css-dsvq8h h2{font-size:2rem;}.css-dsvq8h h3{font-size:1.75rem;}.css-dsvq8h h4{font-size:1.5rem;}.css-dsvq8h h5{font-size:1.25rem;}.css-dsvq8h h6{font-size:1rem;}.css-dsvq8h p{font-weight:400;font-size:1rem;}.css-dsvq8h em{background-color:#fcf8e3;font-style:normal;color:#000;}.css-dsvq8h blockquote{margin:1.25rem -1rem;padding:0.5rem 1.25rem;border:1px solid #eee;border-left-width:0.25rem;border-radius:0.25rem;border-left-color:#f0ad4e;}.css-dsvq8h blockquote cite{text-align:right;color:silver;font-size:1rem;}.css-dsvq8h ul,.css-dsvq8h ol{padding-left:2rem;}.css-dsvq8h .remark-highlight{margin-left:-1rem;margin-right:-1rem;}.css-dsvq8h pre{border-radius:5px;box-shadow:0 0 10px 3px #cacaca;}.css-dsvq8h code{color:#e83e8c;font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:87.5%;}.css-dsvq8h img{box-shadow:0 0 10px 3px rgba(222, 226, 230, 0.548);border-radius:5px;}.css-dsvq8h a{color:#0d6efd;}.css-dsvq8h a:hover{color:#488df5;}.css-dsvq8h a:visited{color:#0a5dda;}.css-dsvq8h a:active{color:#72a6f5;text-shadow:0 0 3px #7e8af8;}</style><article class="css-dsvq8h"><h1>对象原型</h1><hr/><style data-emotion="css 1u87juy">.css-1u87juy:hover svg{visibility:visible;}</style><h2 id="原型和原型链" class="css-1u87juy">原型和原型链<style data-emotion="css 17vkerv">.css-17vkerv{float:left;margin-left:-24px;color:inherit;}.css-17vkerv svg{visibility:hidden;}</style><a href="#原型和原型链" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>每个引用类型数据都会有一个特殊的内置属性 <strong>[<!-- -->[<!-- -->prototype<!-- -->]<!-- -->]</strong> (注意这不是属性名)，这个属性被称作对象的 <strong>原型</strong>，原型可能是一个对象或者 <code>null</code>。</p><p>下面是获取引用类型原型的常用方式：</p><style data-emotion="css l3k28e">.css-l3k28e{overflow-x:auto;margin:1rem -1rem;box-shadow:0 0 10px 3px rgba(222, 226, 230, 0.548);border-radius:5px;}.css-l3k28e table{border-collapse:collapse;min-width:100%;}.css-l3k28e thead tr{border-bottom:1px solid currentColor;}.css-l3k28e tbody tr{border-bottom:1px solid #dee2e6;}.css-l3k28e tbody tr:hover{background-color:#f8f9fa;}.css-l3k28e td,.css-l3k28e th{padding:0.75em;border:inherit;text-align:left;}.css-l3k28e th{white-space:nowrap;}</style><div class="css-l3k28e"><table><thead><tr><th>方式</th><th>描述</th></tr></thead><tbody><tr><td><code>obj.__proto__</code></td><td>通过引用类型的内置属性获取，这个是非标准的方式</td></tr><tr><td><code>Object.getPrototypeOf(obj)</code></td><td>通过 <code>Object.getPrototypeOf</code> 函数获取</td></tr></tbody></table></div><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">,</span> fn<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">getPrototypeOf</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在旧浏览器中上面原型可能无法获得，上面两种方式都可能获取失败，比如 IE 9 以下。</p><p>如果一个对象的原型是引用类型，那么这个原型就也有自己原型，它们都被链式关联到一起，这组原型的链式数据被称为对象的 <strong>原型链</strong>。</p><p>可以通过 <code>.__proto__.__proto__...</code> 这种方式来访问对象的原型链，默认情况下，一个对象的原型指向 <code>Object.prototype</code> 对象，而 <code>Object.prototype</code> 的原型指向 <code>null</code>。<code>null</code> 是原始类型，它没有原型，访问它的原型会出错。</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
obj<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
obj<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">;</span> <span class="token comment">// error null 没有原型</span>
</code></pre></div><h2 id="基于原型链的属性访问" class="css-1u87juy">基于原型链的属性访问<a href="#基于原型链的属性访问" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>当访问一个对象的属性的时候，会在对象内和它的原型链上查找该属性。比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
bar<span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">=</span> foo<span class="token punctuation">;</span>

<span class="token comment">// 原型链： bar {} -&gt; foo { name: &quot;foo&quot; }</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#x27;foo&#x27;</span>
</code></pre></div><p>上述代码把 <code>bar</code> 对象的原型指定为 <code>foo</code> 对象，当我们访问 <code>bar.name</code> 时，会先在 <code>bar</code> 对象找寻找 <code>name</code> 属性，如果没有，就继续向原型链中的对象寻找 <code>name</code> 属性，最后在 <code>foo</code> 对象上找到了属性 <code>name</code>，它被打印了出来。</p><p><strong>使用 <code>Object.create</code> 函数会返回一个空对象，这个空对象会引用传入的参数作为它的原型。</strong> 比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 创建一个空对象，让空对象的原型指向 foo</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#x27;foo&#x27;</span>
</code></pre></div><p>其中，<code>bar</code> 的原型指向 <code>foo</code>，和前面的代码相同。</p><h3 id="[object Object], 关键字" class="css-1u87juy"><code>in</code> 关键字<a href="#[object Object], 关键字" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p><strong>可以用 <code>in</code> 关键字来判断属性是不是在对象或它的原型链上</strong>：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 原型链： bar {} -&gt; foo { name: &quot;foo&quot; }</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span> <span class="token keyword">in</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><p>不论是 <code>&quot;name&quot; in bar</code> 还是 <code>bar.name</code>，它们查找属性 <code>name</code> 的方式都如下【画图演示】：</p><ol><li>到上下文对象中查找属性</li><li>如果找到，返回其属性值，否则到上下文对象的原型上继续查找</li><li>如果找不到并且原型链到头，返回 <code>undefined</code></li></ol><p>不论属性访问、键访问还是使用 <code>in</code> 关键字，都会重复上述操作查找属性。</p><h3 id="属性屏蔽" class="css-1u87juy">属性屏蔽<a href="#属性屏蔽" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>给对象添加或修改属性时，如果对象原型上有同名属性，并不会修改到原型上的属性，比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 给 bar 添加了属性 name</span>
bar<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 原型链： bar { name: &quot;bar&quot; } -&gt; foo { name: &quot;foo&quot; }</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">,</span> bar<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#x27;foo&#x27; &#x27;bar&#x27;</span>
</code></pre></div><p>默认情况下，给对象添加、设置或者访问属性，都会优先基于对象本身去处理，这种情况被称作 <strong>属性屏蔽</strong>。</p><p>比如上面代码中，设置 <code>bar.name</code> 时，被视为给 <code>bar</code> 对象添加属性，这个操作不会改变原型链上的值，然后打印 <code>bar.name</code> 时，因为在 <code>bar</code> 对象中找到了刚添加的 <code>name</code> 属性，就不会再去原型链上寻找。</p><p>不要完全被属性访问迷惑，比如以下代码：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">say</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
bar<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 原型链： bar { name: &quot;bar&quot; } -&gt; foo { name: &quot;foo&quot;, say:function... }</span>
bar<span class="token punctuation">.</span><span class="token method function property-access">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>访问 <code>bar.say</code> 时，的确是从原型上找到了 <code>say</code> 属性，但是 <code>bar.say</code> 是一个显式绑定，内部 <code>this</code> 还是指向上下文对象 <code>bar</code>，又因为属性屏蔽的存在，上述代码打印出来的应该是字符串 &#x27;<code>bar</code>&#x27;。</p><h2 id="Object.prototype" class="css-1u87juy">Object.prototype<a href="#Object.prototype" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>一个普通对象的原型指向 <code>Object.prototype</code> 对象，<code>Object.prototype</code> 的原型一般指向 <code>null</code>，所以当我们建立一个普通的对象时，它的原型链如下：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token comment">// 原型链： foo {} -&gt; object.prototype {...} -&gt; null</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p><code>Object.prototype</code> 是一个对象，它提供了一些内置属性，常用的一般只有一个：</p><div class="css-l3k28e"><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>hasOwnProperty</code></td><td>函数</td><td>传入一个字符串作为属性名，判断该属性是否是当前对象的属性，而非原型链上的属性。是返回 <code>true</code>，反之 <code>false</code>。</td></tr></tbody></table></div><p>根据原型链的访问关系，我们可以访问 <code>Object.prototype</code> 上的属性：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 原型链：bar {} -&gt; foo { name: &quot;foo&quot; } -&gt; Object.prototype {...} -&gt; null</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token method function property-access">isOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token method function property-access">isOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p><code>Object.prototype.hasOwnProperty</code> 和 <code>in</code> 关键字不同，前者是判断属性是否在当前对象上，而 <code>in</code> 关键字是判断属性是否在当前对象或原型链上，<code>in</code> 关键字的查找包括原型链。</p><p>因为 <code>Object.prototype</code> 是几乎所有对象的原型，所以它的属性在大部分对象中都可以直接顺着原型链找到，就像上面的例子，但是有的情况会有例外，比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token keyword null nil">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 原型链： foo {} -&gt; null</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token property-access">hasOwnProperty</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre></div><p>上面例子中，生成的对象原型直接指向 <code>null</code>，因为原型上没有 <code>Object.prototype</code>，所以 <code>hasOwnProperty</code> 自然就访问不到。</p><p><code>Object.prototype</code> 上还有其他属性，因为其余的属性不常用或者兼容性极差，不再介绍，如果你有兴趣，可以点击 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="__blank">这里</a>。</p><h2 id="原型链的属性遍历" class="css-1u87juy">原型链的属性遍历<a href="#原型链的属性遍历" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>一般情况下，我们使用 <code>for in</code> 语句来遍历一个对象及其原型链上的所有可枚举的属性：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
bar<span class="token punctuation">.</span><span class="token property-access">b</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// 原型链： bar { b: 2 } -&gt; foo { a: 1 } -&gt; Object.prototype {...} -&gt; null</span>

<span class="token comment">// 遍历 bar 及其原型链上的属性</span>
<span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">&quot;:&quot;</span> <span class="token operator">+</span> bar<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出</span>
<span class="token comment">// b:2</span>
<span class="token comment">// a:1</span>
</code></pre></div><p>你也许会很意外，大部分对象的原型都是 <code>Object.prototype</code>，那为什么我们使用 <code>for in</code> 遍历对象属性的时候，没有遍历出 <code>Object.prototype</code> 上的属性。这是因为 <strong>有的属性是不可枚举的，这类属性无法遍历</strong>。关于属性是否可以被枚举，可以使用 <code>Object.getOwnPropertyDescriptors</code> 函数查看，比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">getOwnPropertyDescriptors</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打印的结果会显示，<code>Object.prototype</code> 上的属性全都是不可枚举的。如果你打印一个数组的属性状态，你会发现 <code>length</code> 属性也是不可枚举的，所以我们无法使用 <code>for in</code> 语句遍历 <code>length</code> 属性。<strong>属性是否可以被枚举是对象属性的一种状态，我会在深入课程中讲解。</strong></p><p>使用 <code>for in</code> 语句也会产生属性屏蔽，重名属性不会全部遍历：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
bar<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 原型链： bar { name: &quot;bar&quot; } -&gt; foo { name: &quot;foo&quot; } -&gt; ...</span>

<span class="token comment">// 遍历 bar 及其原型链上的属性</span>
<span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">&quot;:&quot;</span> <span class="token operator">+</span> bar<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出</span>
<span class="token comment">// name : bar</span>
</code></pre></div><p>也许你并不想遍历原型链上的属性，所以 <code>for in</code> 一般配合 <code>hasOwnProperty</code> 使用：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
bar<span class="token punctuation">.</span><span class="token property-access">b</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">// 遍历 bar 及其原型链上的属性</span>
<span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token method function property-access">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">&quot;:&quot;</span> <span class="token operator">+</span> bar<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出</span>
<span class="token comment">// b:2</span>
</code></pre></div><p><code>hasOwnProperty</code> 用来判断一个属性是否在当前对象上，而非原型链上。</p><h2 id="设置对象原型" class="css-1u87juy">设置对象原型<a href="#设置对象原型" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>设置原型有以下方式：</p><ul><li>通过设置 <code>__proto__</code> （非标准，但是一些老浏览器只支持这个）</li><li>通过 <code>Object.setPrototypeOf</code>（标准，但是一些老浏览器不支持）</li><li>通过 <code>Object.create</code>（IE9 以下不支持）</li><li>使用 <code>new</code> 关键字</li></ul><h3 id="[object Object], &amp; ,[object Object]" class="css-1u87juy"><code>__proto__</code> &amp; <code>Object.setPrototypeOf</code><a href="#[object Object], &amp; ,[object Object]" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>也可以通过设置对象的 <code>__proto__</code> 属性或者使用 <code>Object.setPrototypeOf</code> 函数来修改对象的原型：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;foo 的原型&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">=</span> bar<span class="token punctuation">;</span>
<span class="token comment">// or Object.setPrototypeOf(foo ,bar)</span>
</code></pre></div><p>但是这种主动设置原型的方式，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="__blank">会带来较大的性能损耗</a>。虽然它们是修改原型最直观的方式，但实际开发中并不推荐。</p><h3 id="通过 Object.create" class="css-1u87juy">通过 Object.create<a href="#通过 Object.create" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>使用 <code>Object.create</code> 函数也可以设置对象的原型，它接受一个对象或者 <code>null</code>，返回一个空对象，空对象的原型指向传入的值。<code>Object.create</code> 还有其他参数，它们可以用于新增属性并且设置属性状态，这部分内容不在本系列课程的讨论范围之内，我会在更深入课程中介绍。</p><p>使用 <code>Object.create</code>，不同于上一节中的直接设置对象原型，这种方式不会给程序带来性能损耗。</p><p><strong>备注：<code>Object.create</code> 在 IE 9 以下无法使用</strong></p><h3 id="[object Object], 关键字" class="css-1u87juy"><code>new</code> 关键字<a href="#[object Object], 关键字" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>每个函数或函数表达式都会拥有一个内置属性 <code>prototype</code>，</p><p><strong>记住这个属性和该函数的原型没有半毛钱关系！</strong>
<strong>记住这个属性和该函数的原型没有半毛钱关系！</strong>
<strong>记住这个属性和该函数的原型没有半毛钱关系！</strong></p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">===</span> foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>上面代码中，我们打印了一个函数的原型和其 <code>prototype</code> 属性，它们并不相等。</p><p>默认情况下，函数的 <code>prototype</code> 指向一个对象，该对象上有一个属性 <code>constructor</code>，这个属性记录了函数本身，这个属性被称作函数的 <strong>构造器</strong>。</p><p>使用 <code>new</code> 关键字修饰函数的执行有且仅有以下两个作用：</p><ul><li><strong>把函数内部的 <code>this</code> 关键字绑定到一个空对象上并作为默认返回值</strong></li><li><strong>这个空对象的原型指向该函数的 <code>prototype</code> 属性</strong></li></ul><p>关于第一点，在 <a href="/jnet-basic/JavaScript/this_%E5%85%B3%E9%94%AE%E5%AD%97/#new-%E7%BB%91%E5%AE%9A" target="__blank">this<!-- -->_<!-- -->关键字</a> 章节中已经介绍过了，不再赘述。通过以下代码可以证实第二点：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 原型链：bar {} -&gt; foo.prototype -&gt; ...</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> foo<span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>上面代码中，<code>bar</code> 对象的原型就指向了 <code>Foo.prototype</code>。目前为止，通过 <code>new</code> 关键字来设置的原型是最被推荐的，因为它可以兼容到骨灰级浏览器，并且也不会带来性能损耗。</p><h2 id="instanceof 原型判断" class="css-1u87juy">instanceof 原型判断<a href="#instanceof 原型判断" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>在 <code>new</code> 关键字一节中介绍，每个函数都内置了一个 <code>prototype</code> 属性，<strong>关键字 <code>instanceof</code> 用来判断一个函数的 <code>prototype</code> 属性是否在某个对象的原型链上</strong>：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Foo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> bar1 <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>bar1 <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>bar2 <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><ul><li>因为 <code>Foo.prototype</code> 在 <code>bar1</code> 的原型链上，所以 <code>bar1 instanceof Foo</code> 是 <code>true</code></li><li>因为 <code>Foo.prototype</code> 不在 <code>bar2</code> 的原型链上，所以 <code>bar2 instanceof Foo</code> 得到 <code>false</code></li></ul><p>注意： <strong><code>instanceof</code> 的左边是一个普通对象，右边是一个函数。</strong></p><p><code>instanceof</code> 关键字经常和 <code>new</code> 关键字配合使用，比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Foo</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Bar</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Baz</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>foo <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>foo <span class="token keyword">instanceof</span> <span class="token class-name">Bar</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>foo <span class="token keyword">instanceof</span> <span class="token class-name">Baz</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>如果基于 <code>new</code> 关键字来理解，那么 <code>instanceof</code> 关键字就是判断一个对象是不是 <code>new</code> 某个函数得来。</p><h2 id="基础数据的原型链" class="css-1u87juy">基础数据的原型链<a href="#基础数据的原型链" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><h3 id="数组" class="css-1u87juy">数组<a href="#数组" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>一个数组被创建后，它的原型链如下：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// foo[] -&gt; Array.prototype {...} -&gt; Object.prototype {...} -&gt; null</span>
</code></pre></div><p>我们前面所学的数组函数例如 <code>push</code>、<code>join</code> 等都在 <code>Array.prototype</code> 上，前面我把它们称作内置属性，实际上它们是原型链上的属性。</p><h3 id="函数" class="css-1u87juy">函数<a href="#函数" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>函数的原型链如下：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// or</span>
<span class="token comment">// var foo = function () {}</span>

foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
foo<span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">===</span> <span class="token keyword null nil">null</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token comment">// foo[] -&gt; Function.prototype {...} -&gt; Object.prototype {...} -&gt; null</span>
</code></pre></div><p>前面学过的显式绑定 <code>call</code>、<code>apply</code>、<code>bind</code> 等函数都是放在 <code>Function.prototype</code> 上，所以才能够访问。</p><h3 id="包装类" class="css-1u87juy">包装类<a href="#包装类" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> numObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> strObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> boolObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 对应原型链</span>
<span class="token comment">// numObj {} -&gt; Number.prototype {...} -&gt; Object.prototype {...} -&gt; null</span>
<span class="token comment">// strObj {} -&gt; String.prototype {...} -&gt; Object.prototype {...} -&gt; null</span>
<span class="token comment">// boolObj {} -&gt; Boolean.prototype {...} -&gt; Object.prototype {...} -&gt; null</span>
</code></pre></div><p>和前面介绍的一样，所有之前提到的内置函数其实都放在原型链上，比如数字的 <code>toFixed</code> 放在 <code>Number.prototype</code> 上，字符串的 <code>search</code> 放在 <code>String.prototype</code> 上。</p><h3 id="原型链小结" class="css-1u87juy">原型链小结<a href="#原型链小结" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>看完上面的原型链，你会发现，其实没有什么内置属性，所有属性需要正常访问，引用类型的数据想要访问到一个属性，它不是在当前对象上，就是在原型链上。</p><h2 id="小结" class="css-1u87juy">小结<a href="#小结" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><ul><li>每个引用类型的数据都存在一个内置属性 <code>[[prototype]]</code>，它被称作引用类型的 <strong>原型</strong>。</li><li>原型可能是一个对象或者 <code>null</code>。</li><li>引用类型的属性访问会顺着原型链查找，同原型链上重名的属性会产生属性屏蔽。</li><li>使用 <code>in</code> 关键字可以判断一个属性是否在对象或其原型链上。</li><li>使用 <code>Object.prototype.hasOwnProperty</code> 可以判断一个属性是否在一个对象上而非其原型链上。</li><li><code>new</code> 关键字修饰一个函数执行会在函数内部创建一个空对象作为 <code>this</code>，这个空对象的原型指向函数的 <code>prototype</code> 属性</li><li><code>instanceof</code> 关键字用以判断一个函数的 <code>prototype</code> 是否在一个对象的原型链上。</li></ul></article></div></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/js/对象原型/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-da8157b780a7e1fd9e9e.js"],"app":["/app-d216605bc40c2cb179d1.js"],"component---src-pages-404-js":["/component---src-pages-404-js-f91e86cfe65092e3adc1.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-57b3b630e72243cc3df9.js"],"component---src-templates-docs-tsx":["/component---src-templates-docs-tsx-58d24a1592ae4305da8e.js"]};/*]]>*/</script><script src="/jnet-basic/polyfill-da8157b780a7e1fd9e9e.js" nomodule=""></script><script src="/jnet-basic/component---src-templates-docs-tsx-58d24a1592ae4305da8e.js" async=""></script><script src="/jnet-basic/1512ff2dbf77859a0dcbee24710e2018e282937f-369ee37846485c1e14f7.js" async=""></script><script src="/jnet-basic/app-d216605bc40c2cb179d1.js" async=""></script><script src="/jnet-basic/framework-e8e53ba50a7a1b0850f7.js" async=""></script><script src="/jnet-basic/webpack-runtime-c0b04000bf61299ee581.js" async=""></script></body></html>