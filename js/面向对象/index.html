<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="HTML，CSS，JavaScript 基础知识 " />
    
<link rel="stylesheet" href="/jnet-basic/css/layout.css">

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/tomorrow-night.css"
      integrity="sha256-qLi5v7wdKdn9AYLccUD3MLqpdfeMqy2ZU2vcImOS2xU="
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"
      integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"
    ></script>
    <title>JNet Basic</title>
  <meta name="generator" content="Hexo 5.2.0"></head>

  <body>
    <div class="sidebar">
  <aside class="sidebar-toc-page"><!--  -->


<div class="toc-page">
  <div class="toc-page-hd">
    <a href="/"> JNet Basic </a>
  </div>
  <ul>
    
<li>
  <a href="/jnet-basic/%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/" class="">课程介绍</a>
</li>

<li>
  <a href="/jnet-basic/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" class="">软件安装</a>
</li>

<li>
  <span class="label">html</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/html/%E6%95%99%E7%BA%B2/" class="">教纲</a>
</li>

<li>
  <a href="/jnet-basic/html/%E6%A6%82%E8%BF%B0/" class="">概述</a>
</li>

<li>
  <a href="/jnet-basic/html/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/" class="">基础理论</a>
</li>

<li>
  <a href="/jnet-basic/html/%E5%A4%B4%E9%83%A8%E5%AD%A6%E4%B9%A0/" class="">头部学习</a>
</li>

<li>
  <span class="label">元素学习</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/html/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%83%E7%B4%A0/" class="">文章相关的元素</a>
</li>

<li>
  <a href="/jnet-basic/html/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E8%B6%85%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%9B%BE%E7%89%87/" class="">超链接与图片</a>
</li>

<li>
  <a href="/jnet-basic/html/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E6%97%A0%E8%AF%AD%E4%B9%89%E5%85%83%E7%B4%A0/" class="">无语义元素</a>
</li>

<li>
  <a href="/jnet-basic/html/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%A0%BC/" class="">表格</a>
</li>

<li>
  <a href="/jnet-basic/html/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/" class="">表单元素</a>
</li>

</ul>

<li>
  <a href="/jnet-basic/html/%E5%B1%9E%E6%80%A7/" class="">属性</a>
</li>

<li>
  <a href="/jnet-basic/html/%E8%A1%A5%E5%85%85%E4%B8%8E%E7%BB%93%E6%9D%9F/" class="">补充与结束</a>
</li>

</ul>

<li>
  <span class="label">css</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/css/%E6%95%99%E7%BA%B2/" class="">教纲</a>
</li>

<li>
  <a href="/jnet-basic/css/%E6%A6%82%E8%BF%B0/" class="">概述</a>
</li>

<li>
  <a href="/jnet-basic/css/%E7%BC%96%E5%86%99_CSS/" class="">编写_CSS</a>
</li>

<li>
  <a href="/jnet-basic/css/CSS_%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/" class="">CSS_引入方式</a>
</li>

<li>
  <a href="/jnet-basic/css/%E9%80%89%E6%8B%A9%E5%99%A8/" class="">选择器</a>
</li>

<li>
  <a href="/jnet-basic/css/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E5%B1%82%E5%8F%A0%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7/" class="">核心概念-层叠，继承，优先级</a>
</li>

<li>
  <a href="/jnet-basic/css/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/" class="">盒模型与文档流</a>
</li>

<li>
  <a href="/jnet-basic/css/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/" class="">文本处理</a>
</li>

<li>
  <a href="/jnet-basic/css/%E8%A1%A8%E6%A0%BC%E5%A4%84%E7%90%86/" class="">表格处理</a>
</li>

<li>
  <a href="/jnet-basic/css/%E8%83%8C%E6%99%AF%E5%A4%84%E7%90%86/" class="">背景处理</a>
</li>

<li>
  <a href="/jnet-basic/css/%E6%9D%82%E9%A1%B9/" class="">杂项</a>
</li>

<li>
  <a href="/jnet-basic/css/%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B1%80/" class="">基础布局</a>
</li>

<li>
  <a href="/jnet-basic/css/%E5%B8%83%E5%B1%80%E8%BF%9B%E9%98%B6/" class="">布局进阶</a>
</li>

<li>
  <a href="/jnet-basic/css/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E7%BB%83%E4%B9%A0/" class="">常见布局练习</a>
</li>

<li>
  <a href="/jnet-basic/css/%E8%A1%A5%E5%85%85%E4%B8%8E%E7%BB%93%E6%9D%9F/" class="">补充与结束</a>
</li>

</ul>

<li>
  <span class="label">js</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/js/%E7%9B%AE%E5%BD%95/" class="">目录</a>
</li>

<li>
  <a href="/jnet-basic/js/%E7%A8%8B%E5%BA%8F%E5%BC%95%E5%AF%BC%E8%AF%BE/" class="">程序引导课</a>
</li>

<li>
  <a href="/jnet-basic/js/%E5%9F%BA%E7%A1%80/" class="">基础</a>
</li>

<li>
  <a href="/jnet-basic/js/%E6%95%B0%E6%8D%AE%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="">数据、运算符和表达式</a>
</li>

<li>
  <a href="/jnet-basic/js/%E5%87%BD%E6%95%B0%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="">函数和作用域</a>
</li>

<li>
  <a href="/jnet-basic/js/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" class="">引用类型</a>
</li>

<li>
  <a href="/jnet-basic/js/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="">流程控制</a>
</li>

<li>
  <a href="/jnet-basic/js/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="">类型判断与类型转换</a>
</li>

<li>
  <a href="/jnet-basic/js/%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/" class="">函数深入</a>
</li>

<li>
  <a href="/jnet-basic/js/%E5%B8%B8%E7%94%A8_API/" class="">常用_API</a>
</li>

<li>
  <a href="/jnet-basic/js/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="">异步编程</a>
</li>

<li>
  <a href="/jnet-basic/js/%E6%8F%90%E5%8D%87/" class="">提升</a>
</li>

<li>
  <a href="/jnet-basic/js/%E9%97%AD%E5%8C%85/" class="">闭包</a>
</li>

<li>
  <a href="/jnet-basic/js/this_%E5%85%B3%E9%94%AE%E5%AD%97/" class="">this_关键字</a>
</li>

<li>
  <a href="/jnet-basic/js/%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/" class="">对象原型</a>
</li>

<li>
  <a href="/jnet-basic/js/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="current">面向对象</a>
</li>

<li>
  <a href="/jnet-basic/js/DOM&BOM/" class="">DOM&BOM</a>
</li>

<li>
  <a href="/jnet-basic/js/%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%8A%A0%E8%BD%BD/" class="">渲染与加载</a>
</li>

<li>
  <a href="/jnet-basic/js/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" class="">错误处理</a>
</li>

<li>
  <a href="/jnet-basic/js/%E5%86%85%E5%AD%98/" class="">内存</a>
</li>

<li>
  <a href="/jnet-basic/js/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" class="">严格模式</a>
</li>

<li>
  <a href="/jnet-basic/js/%E6%AD%A3%E5%88%99%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="">正则字符串</a>
</li>

<li>
  <a href="/jnet-basic/js/%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/" class="">网络简述</a>
</li>

</ul>

<li>
  <a href="/jnet-basic/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/" class="">课程总结</a>
</li>

<li>
  <a href="/jnet-basic/%E7%B4%A0%E6%9D%90/" class="">素材</a>
</li>

  </ul>
</div>
</aside>
  <aside class="sidebar-toc-article"><div class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向过程与面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态属性和静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof-%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">instanceof 和面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">面向对象的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div>
</aside>
</div>
<script>
  $(document).ready(function () {
    var elTocPage = $('.sidebar .sidebar-toc-page').get(0);
    $(elTocPage).on('click', function (elToc) {
      $(this).addClass('show')
    })
    $(document).on('click', function (el) {
      elTocPage.contains(el.target) || $(elTocPage).removeClass('show');
    })
  })
</script>
    <main><article>
  <h1>面向对象</h1>
  <hr />
  <div class="article-bd"><h2 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h2><p>程序有两种开发模式，面向过程和面向对象。目前为止，我们的开发方式都是面向过程的，并没有面向对象开发。</p>
<p>面向对象的开发，只是对数据和逻辑进行另一种方式的封装，面向过程和面向对象的开发方式并没有孰强孰弱。</p>
<p>我们之前的开发练习等，都是面向过程开发的，不会再对面向过程做出介绍。</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>相比面向过程，面向对象更容易对现实世界的事物进行抽象。</p>
<p>就像汽车的制造，总会先做出一个的 <strong>设计图</strong>，然后根据这个设计图，批量生产汽车。这种生产汽车的方式，<strong>是可复制的</strong>，设计师可以通过草图，在汽车没有生产出来的时候，就知道汽车长什么样，用的什么零件，设计了几座等 <strong>数据</strong>，同时还可以知道汽车有什么功能，比如是否有自动挡，是否支持导航，是否支持伸缩敞篷等 <strong>功能（或行为）</strong>。</p>
<p>在面向对象中，也有上述的概念。用来生成汽车的设计图，被我们称作 <strong>类</strong>，汽车的数据被称作 <strong>属性</strong>（这个属性不是指 JS 的对象属性），汽车的功能（或行为）被称作 <strong>方法</strong>，生产出来的汽车被称作 <strong>实例或对象</strong>（此对象的语义是基于面向对象的，和 JS 中的对象类型数据语义不同）。</p>
<p>需要说的是，方法是对现实事物行为或功能的抽象。任何行为和功能，都只是在处理信息而已，比如奔跑提高了身体素质这项数据，说话是在传达思维中的数据，听歌是为了缓解压力这项数据，这些行为都只是在处理信息。行为本身是不具有数据的，它就像程序中的逻辑部分。</p>
<p>在其他语言中，都有面向对象的语法，很遗憾，JS 中并不提供这些语法，在 JS 中，我们可以通过使用函数和原型链的相关知识来模拟面向对象开发。</p>
<p>首先，我们对人的信息和行为进行抽象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name is &quot;</span> + <span class="hljs-built_in">this</span>.name);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> ming = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小明&quot;</span>);<br><span class="hljs-keyword">var</span> hong = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小红&quot;</span>);<br>ming.say();<br>hong.say();<br></code></pre></td></tr></table></figure>

<p>上述代码中，我们使用 <code>Person</code> 函数模拟了一个类，使用对象属性来模拟面向对象的属性和方法，其中 <code>name</code> 是属性，<code>say</code> 是方法，然后我们使用 <code>new</code> 关键字来实例化了这个类，获得了两个实例 <code>ming</code> 和 <code>hong</code>。</p>
<p>这不是最理想的状态，通过 <code>console.log(ming,hong)</code> 可以看到，这两个实例都存在一样的方法，同样的逻辑却占据了两份存储空间。</p>
<p>在 JS 中，我们可以把方法定义到函数的 <code>prototype</code> 上，因为使用 <code>new</code> 关键字修饰的函数，返回的对象原型都指向该函数的 <code>prototype</code>，所以每个实例都可以通过原型链访问这些方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name is &quot;</span> + <span class="hljs-built_in">this</span>.name);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>当我们模拟一个类的时候，函数通常使用大写开头，因为在大部分开发语言中，类都是大写开头。在 JS 中，我们称这些用来模拟类的函数叫做该类的 <strong>构造函数</strong>。</p>
<h2 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h2><p>在面向对象中，属性和方法，都是使用实例去访问。也有的属性或方法，是类本身的数据或行为，它们不属于实例。</p>
<p>比如一瓶可乐的成分介绍，有碳酸，水，糖等，这些属性不是某一瓶可乐特有的，它是可乐这种饮料的属性，而不是某一瓶可乐特有的，如果抽象到程序中，这些属性应该属于类的属性，而不是实例的属性，这种类上面的属性，被称作 <strong>静态属性</strong>，同理还有 <strong>静态方法</strong>。</p>
<p>在 JS 中，我们把类的静态属性和静态方法直接写到构造函数上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Coke</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>Coke.FORMULA = <span class="hljs-string">&quot;成分：碳酸、水、糖......&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>在其他语言中，静态属性和静态方法都不允许更改。在 JS 中并没有要求，因为它们都是模拟的，非特殊情况，静态属性、静态方法和普通方法都没有更改的需要。</p>
<p>静态属性通过类直接去访问，在 JS 中，我们就通过构造函数直接访问：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.PI); <span class="hljs-comment">// 从面相对象上理解，Math 类只有静态属性，比如 Math.sin、 Math.pow ......</span><br></code></pre></td></tr></table></figure>

<p>备注：通常来说，静态属性我们都使用大写命名，静态方法命名和普通方法命名方式一样。</p>
<h2 id="instanceof-和面向对象"><a href="#instanceof-和面向对象" class="headerlink" title="instanceof 和面向对象"></a>instanceof 和面向对象</h2><p>在对象原型的章节，我们介绍过 <code>instanceof</code> 关键字，它被用来判断某个函数的 <code>prototype</code> 是否存在于某个对象的原型链上。</p>
<p>在面向对象中，<code>instanceof</code> 可以理解为一个对象是否是某个类的实例，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OtherClass</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person();<br><br><span class="hljs-built_in">console</span>.log(p <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(p <span class="hljs-keyword">instanceof</span> OtherClass); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>其中 <code>p instanceof Person</code> 这行代码，从语法上分析，它用来判断的是 <code>p</code> 的原型链是否有 <code>Person.prototype</code>，从面向对象上理解，它表示 <code>p</code> 是否是类 <code>Person</code> 的实例。</p>
<h2 id="面向对象的特性"><a href="#面向对象的特性" class="headerlink" title="面向对象的特性"></a>面向对象的特性</h2><p>面向对象有三个基础特性，封装、继承、多态。</p>
<p>也有些其他特性，比如方法重写，重载。</p>
<p>封装是面向对象的设计方式的一大特点，把数据和它们的行为进行融合，编写到类中，在上一节的例子中，已经介绍 JS 中实现对类封装的方式，不过要记住的是，JS 中没有面向对象语法，一切关于面向对象的知识，都只是模拟，本节课并没有介绍新的语法或 API，只是讲解一种新的设计模式，从本质上来说，面向对象就是一种设计模式。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在面向对象的设计中，我们可以把抽象的过程分层，最开始，我们只需要抽象最简单的数据即可。</p>
<p>比如对人进行初步的抽象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name is &quot;</span> + <span class="hljs-built_in">this</span>.name);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>然后我们从 <code>Person</code> 类的基础上，进行学生的抽象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, grade</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.grade = grade;<br>&#125;<br>Student.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name is &quot;</span> + <span class="hljs-built_in">this</span>.name);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>非常明显的可以看到，我们的代码产生了冗余。在面向对象中，基于某个类创建的另一个类，它们之间的关系称作 <strong>继承</strong>，继承不仅限于两层，可以有多层继承。在面向对象中，子类会继承父类的属性和方法，并执行父类的构造函数来构造子类的实例，从而减少代码的冗余。</p>
<p>在上述代码中，<code>Student</code> 类应当继承自 <code>Person</code> 类，<code>Student</code> 作为子类，<code>Person</code> 作为父类。在 JS 中，我们使用 <code>call</code> 或 <code>apply</code> 来执行父类的初始化方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, grade</span>) </span>&#123;<br>  Person.call(<span class="hljs-built_in">this</span>, name);<br>  <span class="hljs-built_in">this</span>.grade = grade;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们使用了一个显式绑定，使用 <code>Person</code> 来处理了一下 <code>Student</code> 内的 <code>this</code> 对象，一个类的属性应该都在其构造函数中被初始化，所以执行父类的构造函数，相当于继承了父类的属性。</p>
<p>接着我们还需要让子类继承父类的方法，目前 <code>Student</code> 类实例的原型链如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Student.prototype -&gt;  Object.prototype -&gt; null<br></code></pre></td></tr></table></figure>

<p>因为父类 <code>Person</code> 的方法都存放在 <code>Person.prototype</code> 上，如果需要让 <code>Student</code> 类继承 <code>Person</code> 类的方法，就要在 <code>Student</code> 实例的原型链上增加 <code>Person.prototype</code>，让 <code>Student</code> 实例的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Student.prototype -&gt; Person.prototype -&gt; Object.prototype -&gt; null<br></code></pre></td></tr></table></figure>

<p>很明显，只要改变 <code>Student.prototype</code> 的原型为 <code>Person.prototype</code> 即可，最简单的方式就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.setPrototypeOf(Student.prototype, Person.prototype);<br><span class="hljs-comment">// or</span><br>Student.prototype.__proto__ = Person.prototype;<br></code></pre></td></tr></table></figure>

<p>但是以上方式并不是很好的实现，原型的动态修改会降低 JS 性能，同时，<code>setPrototypeOf</code> 不支持老版本浏览器，<code>__proto__</code> 又是非标准的实现，不是所有浏览器都支持，基于这些原因，实际开发中 JS 没有使用上述方式来继承父类的方法，更换以下方式实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, birth</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.birth = birth;<br>&#125;<br>Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name is &quot;</span> + <span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br>Student.prototype = <span class="hljs-keyword">new</span> Person();<br>Student.prototype.constructor = Student;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, birth, grade</span>) </span>&#123;<br>  Person.call(<span class="hljs-built_in">this</span>, name, birth);<br>  <span class="hljs-built_in">this</span>.grade = grade;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>new Person()</code> 得到一个原型指向 <code>Person.prototype</code> 的对象，用这个对象作为 <code>Student.prototype</code>。因为每个函数的 <code>prototype</code> 都有一个 <code>constructor</code> 属性指向自身，所以需要修复。这样我们就实现了 <code>Student</code> 实例对 <code>Person</code> 方法的继承。</p>
<p>上面代码中，<code>Student</code> 类实例的原型链如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Student.prototype(new Person 得来) -&gt; Person.prototype -&gt; Object.prototype -&gt; null<br></code></pre></td></tr></table></figure>

<p>这种继承方式被称作 <strong>寄生式组合继承</strong>，这是 JS 中最常见和使用最广泛的继承方式。</p>
<p>现在 <code>Student</code> 的实例继承 <code>Person</code> 类的属性，也继承 <code>Person</code> 类的方法，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ming = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;明&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">&quot;一年级&quot;</span>);<br>ming.say(); <span class="hljs-comment">// &#x27;name is 明&#x27;</span><br></code></pre></td></tr></table></figure>

<p>上述代码中，<code>Student</code> 的实例执行了父类的 <code>say</code> 方法，<code>say</code> 方法内也访问父级定义的 <code>name</code> 属性。自此，我们在 JS 中完成了类的继承。</p>
<p>但是上述继承方式，有一个比较大的缺陷是，<code>Student.prototype</code> 是使用 <code>new</code> 关键字修饰 <code>Person</code> 得来的，<code>new Person()</code> 的执行会产生一定程度的副作用。</p>
<p>在程序最后打印 <code>Student.prototype</code> 会得到一个奇奇怪怪的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Person &#123;name: undefined, birth: undefined, constructor: ƒ&#125;<br></code></pre></td></tr></table></figure>

<p>把上面的对象记作 A，目前 <code>Student</code> 实例的原型就是 A，它的原型链是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">A -&gt; Person.prototype -&gt; Object.prototype -&gt; null<br></code></pre></td></tr></table></figure>

<p>A 会作为所有 <code>Student</code> 类实例的原型，<code>name</code> 和 <code>birth</code> 属性是我们使用 <code>new Person</code> 带来的副作用，如果 <code>Person</code> 函数中有其他影响巨大的副作用，比如定时器等：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, birth</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.birth = birth;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;do something&quot;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时使用 <code>new Person</code> 作为 <code>Student.prototype</code> 的话，程序就会多余执行一个定时器，可以使用以下方式来消除这个副作用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SpacePerson</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>SpacePerson.prototype = Person.prototype;<br>Student.prototype = <span class="hljs-keyword">new</span> SpacePerson();<br>Student.prototype.constructor = Student;<br></code></pre></td></tr></table></figure>

<p>上面代码中，我们声明了一个空函数，来代替 <code>Person</code> ，把 <code>SpacePerson.prototype</code> 指向 <code>Person.prototype</code>，<code>new SpacePerson</code> 就不会有任何副作用，相当于抹去了 <code>Person</code> 函数的内部执行。此时，<code>Student</code> 实例的原型链就为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Student.prototype(new SpacePerson 得来) -&gt; Person.prototype -&gt; Object.prototype -&gt; null<br></code></pre></td></tr></table></figure>

<p>通常来说，继承的代码不会暴露在外面，我们封装一个函数来实现上述继承：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inherit</span>(<span class="hljs-params">SubClass, SuperClass</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = SuperClass.prototype;<br>  SubClass.prototype = <span class="hljs-keyword">new</span> F();<br>  SubClass.prototype.constructor = SubClass;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在使用 <code>_inherit</code> 函数来实现继承：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inherit</span>(<span class="hljs-params">SubClass, SuperClass</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = SuperClass.prototype;<br>  SubClass.prototype = <span class="hljs-keyword">new</span> F();<br>  SubClass.prototype.constructor = SubClass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, birth</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.birth = birth;<br>&#125;<br>Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name is &quot;</span> + <span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br>_inherit(Student, Person);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, birth, grade</span>) </span>&#123;<br>  Person.call(<span class="hljs-built_in">this</span>, name, birth);<br>  <span class="hljs-built_in">this</span>.grade = grade;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述继承方式依旧是寄生式组合继承，只是重新进行了封装。</p>
<p>寄生式组合继承的原则是以下两点：</p>
<ul>
<li>子类的构造函数内执行父类的构造函数</li>
<li>子类实例的原型链上继承了父类的方法</li>
</ul>
<p>关于第一条，只要在子类的构造函数中，使用 <code>SuperClass.call(this,...)</code> 就可以实现，第二条我们使用了 <code>_inherit</code> 函数封装实现，根据定义，<code>_inherit</code> 的实现方式有多种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用 `new` 关键字</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inherit</span>(<span class="hljs-params">SubClass, SuperClass</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = SuperClass.prototype;<br>  SubClass.prototype = <span class="hljs-keyword">new</span> F();<br>  SubClass.prototype.constructor = SubClass;<br>&#125;<br><br><span class="hljs-comment">// 使用 Object.create 低版本浏览器不兼容</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inherit2</span>(<span class="hljs-params">SubClass, SuperClass</span>) </span>&#123;<br>  SubClass.prototype = <span class="hljs-built_in">Object</span>.create(SuperClass.prototype);<br>  SubClass.prototype.constructor = SubClass;<br>&#125;<br><br><span class="hljs-comment">// 直接设置原型，会降低运行效率</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inherit3</span>(<span class="hljs-params">SubClass, SuperClass</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.setPrototypeOf) &#123;<br>    <span class="hljs-built_in">Object</span>.setPrototypeOf(SubClass.prototype, SuperClass.prototype);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    SubClass.prototype.__proto__ = SuperClass.prototype;<br>  &#125;<br>  <span class="hljs-comment">// // or</span><br>  <span class="hljs-comment">// Object.setPrototypeOf ? Object.setPrototypeOf(SubClass.prototype, SuperClass.prototype) : (SubClass.prototype.__proto__ = SuperClass.prototype);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用以上的函数都可以在 JS 中完成类方法的继承。</p>
<p>对寄生式组合继承简化后，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-comment">// 方法继承</span><br>_inherit(Student, Person);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 父类构造函数访问</span><br>  Person.call(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>子类继承父类，只是继承属性和方法，不会继承静态属性或静态方法，同时子类可以添加新的属性或新的方法。</strong></p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>在某些语言中，一个方法可以被定义多次，由它们的参数规则来区分如何调用。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 伪代码<br>class Compute &#123;<br>  method add (a,b) &#123;<br>    return a + b;<br>  &#125;<br>  method add (a,b,c) &#123;<br>    return a + b + c;<br>  &#125;<br>&#125;<br><br>a &#x3D; new Math();<br>a.add(1,2); &#x2F;&#x2F; 3<br>a.add(1,2,3); &#x2F;&#x2F; 6<br></code></pre></td></tr></table></figure>

<p>类似上面的伪代码，我们定义了一个类 <code>Compute</code>，它有两个同名方法 <code>add</code> ，当我们调用 <code>add</code> 方法的时候，根据传入的参数不同，程序引擎会自动识别，然后选择符合条件的那个执行。</p>
<p>这种在同一个类中，同一个方法，因不同参数被重复声明的行为被称作 <strong>重载</strong>。</p>
<p>JS 中没有重载，同一个方法重复声明会被覆盖，因为我们是用 JS 对象属性来模拟方法的。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Compute</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>Compute.prorotype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br>Compute.prorotype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b + c;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上述代码中，第二次对 <code>add</code> 方法的定义会被覆盖，因为在 JS 中 <code>prototype.add</code> 只是一个普通的对象属性。</p>
<p>在 JS 中，方法重载需要程序员手动实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Compute</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>Compute.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_add1</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_add2</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>  &#125;<br><br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-keyword">return</span> _add1.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-keyword">return</span> _add2.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> comp = <span class="hljs-keyword">new</span> Compute();<br>comp.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br>comp.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure>

<p>上述代码中，我们自己判断了参数个数，实现了方法的重载。【代码解释】</p>
<p>上面是一种简单的实现重载的方式，通过参数数量来判断，方法重载并不一定只是参数不同，也有可能是参数相同，但是参数类型不同，需要根据不同的重载来编写不同的分支。</p>
<p>因为在 JS 中重载是被我们自己实现的，所以重载并不局限于类的方法中，普通函数也可以实现重载。如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_add1</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_add2</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>  &#125;<br><br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-keyword">return</span> _add1.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-keyword">return</span> _add2.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure>

<p><strong>小结：在同一个类中，重复定义一个方法，参数的类型或数量不同，这种情况才被称作重载。</strong></p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>重写定义如下：子类继承父类，子类重新定义父类的方法，并且参数和父类的方法完全相同。</p>
<p>为什么会有重写？可以看如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bird</span>(<span class="hljs-params">type</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.type = type;<br>&#125;<br>Bird.prototype.fly = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.type + <span class="hljs-string">&quot;会飞&quot;</span>);<br>&#125;;<br><br>Penguin.prototype.__proto__ = Bird.prototype;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Penguin</span>(<span class="hljs-params"></span>) </span>&#123;<br>  Bird.call(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;企鹅&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> Penguin = <span class="hljs-keyword">new</span> Penguin();<br><br>Penguin.fly(); <span class="hljs-comment">// 企鹅会飞</span><br></code></pre></td></tr></table></figure>

<p>企鹅虽然属于鸟类，但是企鹅被不会飞行，如果 <code>Penguin</code> 类不重新定义父类的 <code>fly</code> 方法，那就会出现一些预料之外的行为。</p>
<p>关于上述例子，我们需要重新定义 <code>Penguin</code> 类的 <code>fly</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">Penguin.prototype.fly = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.type + <span class="hljs-string">&quot;并不会飞&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>重写并不是想上面一样否定这个行为，也可能是扩展，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pen</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 墨水</span><br>  <span class="hljs-built_in">this</span>.ink = <span class="hljs-number">100</span>;<br>&#125;<br><br>Pen.prototype.write = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.ink &gt; text.length) &#123;<br>    <span class="hljs-built_in">this</span>.ink -= text.length;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是编写的文本：&quot;</span> + text);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;墨水不够编写文本：&quot;</span> + text);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;;<br><br>_inherit(ColourPen, Pen);<br><span class="hljs-comment">// 彩笔</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ColourPen</span>(<span class="hljs-params">color</span>) </span>&#123;<br>  Pen.call(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-built_in">this</span>.color = color;<br>&#125;<br><br>ColourPen.prototype.write = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (Pen.prototype.write.call(<span class="hljs-built_in">this</span>, text)) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这几个字的颜色是&quot;</span> + <span class="hljs-built_in">this</span>.color);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，<code>ColourPen</code> 类重写了 <code>write</code> 方法，扩展了父类 <code>write</code> 方法。这也是开发中重写常用的方式。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是面向对象的一大特色，字面意思就是多种状态，指的主要是类中方法的多种状态。</p>
<p>多态产生的条件：</p>
<ul>
<li>继承</li>
<li>子类重写父类方法</li>
<li>父类引用子类对象</li>
</ul>
<p>前两个条件我们已经实现了，关键是第三个条件的理解。</p>
<p>观察以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name is &quot;</span> + <span class="hljs-built_in">this</span>.name);<br>&#125;;<br><br>_inherit(Student, Person);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, grade</span>) </span>&#123;<br>  Person.call(<span class="hljs-built_in">this</span>, name);<br>  <span class="hljs-built_in">this</span>.grade = grade;<br>&#125;<br>Student.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name is &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;,It&#x27;s a student&quot;</span>);<br>&#125;;<br><br>_inherit(Dirver, Person);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dirver</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  Person.call(<span class="hljs-built_in">this</span>, name);<br>&#125;<br>Dirver.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name is &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;,It&#x27;s a dirver&quot;</span>);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSay</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Person) &#123;<br>    obj.say();<br>  &#125;<br>&#125;<br><br>doSay(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;明&quot;</span>)); <span class="hljs-comment">// name is 明,It&#x27;s a student</span><br>doSay(<span class="hljs-keyword">new</span> Dirver(<span class="hljs-string">&quot;陈&quot;</span>)); <span class="hljs-comment">// name is 陈,It&#x27;s a dirver</span><br></code></pre></td></tr></table></figure>

<p>在上述代码中，<code>Student</code> 类和 <code>Dirver</code> 类都继承自 <code>Person</code> 类，并且重写的 <code>say</code> 方法，完成了多态的前两个条件。</p>
<p>从面向对象的角度观察 <code>doSay</code> 函数，我们判断传入的对象是否是 <code>Person</code> 的实例，如果是，执行 <code>Person</code> 类的 <code>say</code> 方法。</p>
<p>但是我们后来传入了 <code>Student</code> 类和 <code>Dirver</code> 类的实例，它们被顺利执行了。在 <code>doSay</code> 函数中，基于 <code>Person</code> 类引用了其子类实例的 <code>say</code> 方法，它满足了多态的第三个条件，父类引用子类实例。</p>
<p>最后的结果也显而易见，父类的 <code>say</code> 方法在子类中的不同形态得以表现，这就是面向对象的多态。</p>
<p>多态常被用来在父类方法的基础上做出一定的修改，或者将某些行为插入到父类中。</p>
<p>这个 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/example-of-polymorphism-8l34g">多态例子</a> 模拟了一个输出信息到控制台的类，并在子类上运用到了多态。</p>
<p><strong>需要注意的是，方法重载和多态并没有关系。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 JS 中，并不支持面向对象开发，在 JS 中，只能基于 JS 原始的特性和语法模拟面向对象开发。面向对象是一种设计模式，使用面向对象的思维来抽象实际问题大部分情况下，都可以起到事半功倍的效果。</p>
<ul>
<li><p>在面向对象中</p>
<ul>
<li><p>类就像实际问题的设计图</p>
</li>
<li><p>事物的数据信息和行为被抽象成来了类的属性和方法</p>
</li>
<li><p>属于类的属性和方法称作静态属性与静态方法</p>
</li>
<li><p>基于某个类生成的对象被称作这个类的实例</p>
</li>
<li><p>类的方法有重载和重写特性</p>
<ul>
<li>同一个类中，可能存在参数不同的同名方法，这种重复声明的方式称作重载</li>
<li>子类可以重新定义父类方法，参数必须相同，这种重复声明的方式称作重写</li>
</ul>
</li>
<li><p>面向对象有三大特性：封装、继承、多态</p>
<ul>
<li>面向对象开发，会基于对象本身，把它的数据和行为封装到一个类中，面向对象提供非常好的封装性</li>
<li>基于一个类的派生的类，它们存在继承关系。在面向对象中，可以让派生出的类继承自原始类，子类会继承父类的属性和方法（不会继承父类的静态属性和静态方法）</li>
<li>多态是指父类方法在不同子类中得以不同形态的展现。</li>
</ul>
</li>
</ul>
</li>
<li><p>在 JS 中</p>
<ul>
<li><p>使用函数来模拟类，用来模拟类的函数也叫作类的构造函数。</p>
</li>
<li><p>使用对象属性来模拟类的属性，在构造函数的 <code>prototype</code> 上定义函数来模拟类的方法</p>
</li>
<li><p>类的实例使用 <code>new</code> 关键字修饰函数执行得到</p>
</li>
<li><p>方法重载需要主动实现</p>
</li>
<li><p>方法重写依靠原型链的属性屏蔽</p>
</li>
<li><p>类的继承基于对父类构造函数的调用和原型链的委托（这里单指寄生式组合继承）</p>
</li>
<li><p>实例与类的关系使用 <code>instanceof</code> 关键字的结果模拟</p>
</li>
</ul>
</li>
</ul>
</div>
  <div class="article-ft">
    <p>
      <span class="last-update">最后更新时间：2020/12/02</span>
    </p>
  </div>
</article>
</main>
    <script>
      $(document).ready(function () {
        $("article table:not(.highlight table)").addClass("table table-hover");
        $("article blockquote").addClass("blockquote");
      });
    </script>
  </body>
</html>
