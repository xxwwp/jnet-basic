<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 3.0.2"/><title data-react-helmet="true"></title><link data-react-helmet="true" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism-tomorrow.css"/><link as="script" rel="preload" href="/jnet-basic-v2/webpack-runtime-a52939d631f5cc604aea.js"/><link as="script" rel="preload" href="/jnet-basic-v2/framework-e8e53ba50a7a1b0850f7.js"/><link as="script" rel="preload" href="/jnet-basic-v2/app-38218a2ef72326a75367.js"/><link as="script" rel="preload" href="/jnet-basic-v2/1512ff2dbf77859a0dcbee24710e2018e282937f-369ee37846485c1e14f7.js"/><link as="script" rel="preload" href="/jnet-basic-v2/component---src-templates-docs-tsx-3f6722c11400634ddec5.js"/><link as="fetch" rel="preload" href="/jnet-basic-v2/page-data/js/面向对象/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/jnet-basic-v2/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css-global b48ifx">body{margin:0;}html,body{overflow-x:hidden;}</style><style data-emotion="css-global 1vo6k5w">body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";color:#303133;}</style><style data-emotion="css zdq125">.css-zdq125{position:fixed;left:0;top:0;bottom:0;-webkit-transition:-webkit-transform 0.3s,opacity 0.3s;transition:transform 0.3s,opacity 0.3s;overflow:hidden;z-index:10;}@media screen and (min-width: 1200px){.css-zdq125:hover{overflow:auto;overflow:overlay;}}@media screen and (max-width: 1200px){.css-zdq125{opacity:0;-webkit-transform:translateX(-100%);-moz-transform:translateX(-100%);-ms-transform:translateX(-100%);transform:translateX(-100%);}.css-zdq125.active{opacity:1;-webkit-transform:translateX(0);-moz-transform:translateX(0);-ms-transform:translateX(0);transform:translateX(0);overflow:auto;overflow:overlay;}.css-zdq125 nav{width:100vw;}}</style><aside class=" css-zdq125"><style data-emotion="css k4cgyt">.css-k4cgyt{width:200px;overflow:hidden;padding:10px 0px 50px;border-right:4px double rgba(0, 0, 0, 0.1);min-height:100%;background:#fff;}.css-k4cgyt .title{text-align:center;}.css-k4cgyt .title a{line-height:40px;color:#c0c0c0;-webkit-text-decoration:none;text-decoration:none;font-size:1.5em;}</style><nav class="css-k4cgyt"><div class="title"><a href="/jnet-basic-v2/">JNet Basic</a></div><style data-emotion="css smzts4">.css-smzts4 ol{list-style:none;padding-left:20px;margin:0;}.css-smzts4 ol ol{padding-left:10px;}.css-smzts4 ol li{line-height:30px;margin:0;}.css-smzts4 ol a{color:#555;-webkit-text-decoration:none;text-decoration:none;line-height:30px;}.css-smzts4 ol a:hover,.css-smzts4 ol a.current{color:#999;}</style><div class="css-smzts4"><ol><li><style data-emotion="css opu5s9">.css-opu5s9.active{color:#999;}</style><a class="css-opu5s9" href="/jnet-basic-v2/课程介绍">课程介绍</a></li><li><span>html</span><ol><li><a class="css-opu5s9" href="/jnet-basic-v2/html/概述">概述</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/html/基础理论">基础理论</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/html/头部学习">头部学习</a></li><li><span>元素学习</span><ol><li><a class="css-opu5s9" href="/jnet-basic-v2/html/元素学习/文章相关的元素">文章相关的元素</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/html/元素学习/超链接与图片">超链接与图片</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/html/元素学习/无语义元素">无语义元素</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/html/元素学习/表格">表格</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/html/元素学习/表单元素">表单元素</a></li></ol></li><li><a class="css-opu5s9" href="/jnet-basic-v2/html/属性">属性</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/html/补充与结束">补充与结束</a></li></ol></li><li><span>css</span><ol><li><a class="css-opu5s9" href="/jnet-basic-v2/css/概述">概述</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/选择器">选择器</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/核心概念-层叠，继承，优先级">核心概念-层叠，继承，优先级</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/盒模型与文档流">盒模型与文档流</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/文本处理">文本处理</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/表格处理">表格处理</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/背景处理">背景处理</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/杂项">杂项</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/基础布局">基础布局</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/布局进阶">布局进阶</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/常见布局练习">常见布局练习</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/css/补充与结束">补充与结束</a></li></ol></li><li><span>js</span><ol><li><a class="css-opu5s9" href="/jnet-basic-v2/js/程序引导课">程序引导课</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/基础">基础</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/数据、运算符和表达式">数据、运算符和表达式</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/函数和作用域">函数和作用域</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/引用类型">引用类型</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/流程控制">流程控制</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/类型判断与类型转换">类型判断与类型转换</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/函数深入">函数深入</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/常用_API">常用_API</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/异步编程">异步编程</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/提升">提升</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/闭包">闭包</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/this_关键字">this_关键字</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/对象原型">对象原型</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象">面向对象</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/DOM">DOM</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/事件">事件</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/BOM">BOM</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/渲染与加载">渲染与加载</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/错误处理">错误处理</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/严格模式">严格模式</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/正则字符串">正则字符串</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/网络简述">网络简述</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/杂项">杂项</a></li></ol></li><li><a class="css-opu5s9" href="/jnet-basic-v2/总练习">总练习</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/课程总结">课程总结</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/素材">素材</a></li></ol></div></nav></aside><style data-emotion="css 1308utl">.css-1308utl{position:fixed;right:1rem;bottom:1rem;z-index:100;background-color:rgba(82, 122, 253, 0.37);border-radius:50%;padding:10px;border:none;width:20px;height:20px;box-sizing:content-box;-webkit-transition:background-color 0.3s;transition:background-color 0.3s;}@media screen and (min-width: 1200px){.css-1308utl{display:none;}}.css-1308utl svg{width:inherit;height:inherit;-webkit-transition:-webkit-transform 0.3s;transition:transform 0.3s;-webkit-transform:rotateX(0);-moz-transform:rotateX(0);-ms-transform:rotateX(0);transform:rotateX(0);}.css-1308utl.active{background-color:rgba(0, 0, 0, 0.123);}.css-1308utl.active svg{-webkit-transform:rotateX(180deg);-moz-transform:rotateX(180deg);-ms-transform:rotateX(180deg);transform:rotateX(180deg);}</style><button class=" css-1308utl"><svg enable-background="new 0 0 32 32" id="Слой_1" version="1.1" viewBox="0 0 32 32"><path d="M24.285,11.284L16,19.571l-8.285-8.288c-0.395-0.395-1.034-0.395-1.429,0  c-0.394,0.395-0.394,1.035,0,1.43l8.999,9.002l0,0l0,0c0.394,0.395,1.034,0.395,1.428,0l8.999-9.002  c0.394-0.395,0.394-1.036,0-1.431C25.319,10.889,24.679,10.889,24.285,11.284z" fill="#121313" id="Expand_More"></path><g></g><g></g><g></g><g></g><g></g><g></g></svg></button><style data-emotion="css 117dd4v">.css-117dd4v{margin:auto;width:90%;max-width:760px;}.css-117dd4v .article-container{padding:50px 10px;}.css-117dd4v .article-catalog{position:fixed;top:0;left:80%;left:calc(50% + 380px);bottom:0;overflow:hidden;z-index:10;}.css-117dd4v .article-catalog:hover{overflow:auto;overflow:overlay;padding-right:1rem;}@media screen and (max-width: 1200px){.css-117dd4v .article-catalog{display:none;}}</style><main class="css-117dd4v"><aside class="article-catalog"><style data-emotion="css f4f9ae">.css-f4f9ae{padding:20px 0;white-space:nowrap;min-width:120px;box-sizing:content-box;}.css-f4f9ae .title{padding-left:20px;margin-bottom:20px;font-size:1.2em;font-weight:lighter;}</style><nav class="css-f4f9ae"><div class="title">目录</div><style data-emotion="css smzts4">.css-smzts4 ol{list-style:none;padding-left:20px;margin:0;}.css-smzts4 ol ol{padding-left:10px;}.css-smzts4 ol li{line-height:30px;margin:0;}.css-smzts4 ol a{color:#555;-webkit-text-decoration:none;text-decoration:none;line-height:30px;}.css-smzts4 ol a:hover,.css-smzts4 ol a.current{color:#999;}</style><div class="css-smzts4"><ol><li><style data-emotion="css opu5s9">.css-opu5s9.active{color:#999;}</style><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#面向过程与面向对象">面向过程与面向对象</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#基础概念">基础概念</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#静态属性和静态方法">静态属性和静态方法</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#instanceof 和面向对象">instanceof 和面向对象</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#面向对象的特性">面向对象的特性</a><ol><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#继承">继承</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#多重继承">多重继承</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#方法重载">方法重载</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#方法重写">方法重写</a></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#多态">多态</a></li></ol></li><li><a class="css-opu5s9" href="/jnet-basic-v2/js/面向对象/#总结">总结</a></li></ol></div></nav></aside><div class="article-container"><style data-emotion="css dsvq8h">.css-dsvq8h{line-height:1.5;}.css-dsvq8h h1,.css-dsvq8h h2,.css-dsvq8h h3,.css-dsvq8h h4,.css-dsvq8h h5,.css-dsvq8h h6{font-weight:500;line-height:1.2;color:#212529;}.css-dsvq8h h1 a,.css-dsvq8h h2 a,.css-dsvq8h h3 a,.css-dsvq8h h4 a,.css-dsvq8h h5 a,.css-dsvq8h h6 a,.css-dsvq8h h1 a:hover,.css-dsvq8h h2 a:hover,.css-dsvq8h h3 a:hover,.css-dsvq8h h4 a:hover,.css-dsvq8h h5 a:hover,.css-dsvq8h h6 a:hover,.css-dsvq8h h1 a:active,.css-dsvq8h h2 a:active,.css-dsvq8h h3 a:active,.css-dsvq8h h4 a:active,.css-dsvq8h h5 a:active,.css-dsvq8h h6 a:active,.css-dsvq8h h1 a:visited,.css-dsvq8h h2 a:visited,.css-dsvq8h h3 a:visited,.css-dsvq8h h4 a:visited,.css-dsvq8h h5 a:visited,.css-dsvq8h h6 a:visited{color:inherit;}.css-dsvq8h h1{font-size:2.5rem;}.css-dsvq8h h2{font-size:2rem;}.css-dsvq8h h3{font-size:1.75rem;}.css-dsvq8h h4{font-size:1.5rem;}.css-dsvq8h h5{font-size:1.25rem;}.css-dsvq8h h6{font-size:1rem;}.css-dsvq8h p{font-weight:400;font-size:1rem;}.css-dsvq8h em{background-color:#fcf8e3;font-style:normal;color:#000;}.css-dsvq8h blockquote{margin:1.25rem -1rem;padding:0.5rem 1.25rem;border:1px solid #eee;border-left-width:0.25rem;border-radius:0.25rem;border-left-color:#f0ad4e;}.css-dsvq8h blockquote cite{text-align:right;color:silver;font-size:1rem;}.css-dsvq8h ul,.css-dsvq8h ol{padding-left:2rem;}.css-dsvq8h .remark-highlight{margin-left:-1rem;margin-right:-1rem;}.css-dsvq8h pre{border-radius:5px;box-shadow:0 0 10px 3px #cacaca;}.css-dsvq8h code{color:#e83e8c;font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:87.5%;}.css-dsvq8h img{box-shadow:0 0 10px 3px rgba(222, 226, 230, 0.548);border-radius:5px;}.css-dsvq8h a{color:#0d6efd;}.css-dsvq8h a:hover{color:#488df5;}.css-dsvq8h a:visited{color:#0a5dda;}.css-dsvq8h a:active{color:#72a6f5;text-shadow:0 0 3px #7e8af8;}</style><article class="css-dsvq8h"><h1>面向对象</h1><hr/><style data-emotion="css 1u87juy">.css-1u87juy:hover svg{visibility:visible;}</style><h2 id="面向过程与面向对象" class="css-1u87juy">面向过程与面向对象<style data-emotion="css 17vkerv">.css-17vkerv{float:left;margin-left:-24px;color:inherit;}.css-17vkerv svg{visibility:hidden;}</style><a href="#面向过程与面向对象" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>程序有两种开发模式，面向过程和面向对象。目前为止，我们的开发方式都是面向过程的，并没有面向对象开发。</p><p>面向对象的开发，只是对数据和逻辑进行另一种方式的封装，面向过程和面向对象的开发方式并没有孰强孰弱。</p><p>我们之前的开发练习等，都是面向过程开发的，不会再对面向过程做出介绍。</p><h2 id="基础概念" class="css-1u87juy">基础概念<a href="#基础概念" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>相比面向过程，面向对象更容易对现实世界的事物进行抽象。</p><p>就像汽车的制造，总会先做出一个的 <strong>设计图</strong>，然后根据这个设计图，批量生产汽车。这种生产汽车的方式，<strong>是可复制的</strong>，设计师可以通过草图，在汽车没有生产出来的时候，就知道汽车长什么样，用的什么零件，设计了几座等 <strong>数据</strong>，同时还可以知道汽车有什么功能，比如是否有自动挡，是否支持导航，是否支持无人驾驶等 <strong>功能（或行为）</strong>。</p><p>在面向对象中，也有上述的概念。用来生成汽车的设计图，被我们称作 <strong>类</strong>，汽车的数据被称作 <strong>属性</strong>（这个属性不是指 JS 的对象属性），汽车的功能（或行为）被称作 <strong>方法</strong>，生产出来的汽车被称作 <strong>实例或对象</strong>（此对象的语义是基于面向对象的，和 JS 中的对象类型数据语义不同）。</p><p>需要说的是，方法是对现实事物行为或功能的抽象。任何行为和功能，都只是在处理信息而已，比如奔跑提高了身体素质这项数据，说话是在传达思维中的数据，听歌是为了缓解压力这项数据，这些行为都只是在处理信息。行为本身是不具有数据的，它就像程序中的逻辑部分。</p><p>在其他语言中，都有面向对象的语法，很遗憾，JS 中并不提供这些语法，在 JS 中，我们可以通过使用函数和原型链的相关知识来模拟面向对象开发。</p><p>首先，我们对人的信息和行为进行抽象：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;name is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> ming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> hong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;小红&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ming<span class="token punctuation">.</span><span class="token method function property-access">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
hong<span class="token punctuation">.</span><span class="token method function property-access">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上述代码中，我们使用 <code>Person</code> 函数模拟了一个类，使用对象属性来模拟面向对象的属性和方法，其中 <code>name</code> 是属性，<code>say</code> 是方法，然后我们使用 <code>new</code> 关键字来实例化了这个类，获得了两个实例 <code>ming</code> 和 <code>hong</code>。</p><p>这不是最理想的状态，通过 <code>console.log(ming,hong)</code> 可以看到，这两个实例都存在一样的方法，同样的逻辑却占据了两份存储空间。</p><p>在 JS 中，我们可以把方法定义到函数的 <code>prototype</code> 上，因为使用 <code>new</code> 关键字修饰的函数，返回的对象原型都指向该函数的 <code>prototype</code>，所以每个实例都可以通过原型链访问这些方法。</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;name is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>当我们模拟一个类的时候，函数通常使用大写开头，因为在大部分开发语言中，类都是大写开头。在 JS 中，我们称这些用来模拟类的函数叫做该类的 <strong>构造函数</strong>。</p><h2 id="静态属性和静态方法" class="css-1u87juy">静态属性和静态方法<a href="#静态属性和静态方法" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>在面向对象中，属性和方法，都是使用实例去访问。也有的属性或方法，是类本身的数据或行为，它们不属于实例。</p><p>比如一瓶可乐的成分介绍，有碳酸，水，糖等，这些属性不是某一瓶可乐特有的，它是可乐这种饮料的属性，如果抽象到程序中，这些属性应该属于类的属性，而不是实例的属性，这种类上面的属性，被称作 <strong>静态属性</strong>，同理还有 <strong>静态方法</strong>。</p><p>在 JS 中，我们把类的静态属性和静态方法直接写到构造函数上：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Coke</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token maybe-class-name">Coke</span><span class="token punctuation">.</span><span class="token constant">FORMULA</span> <span class="token operator">=</span> <span class="token string">&quot;成分：碳酸、水、糖......&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>在其他语言中，静态属性和静态方法都不允许更改。在 JS 中并没有要求，因为它们都是模拟的，非特殊情况，静态属性、静态方法和普通方法都没有更改的需要。</p><p>静态属性通过类直接去访问，在 JS 中，可以通过构造函数直接访问：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token comment">// 从面相对象上理解，Math 类只有静态属性和静态方法，比如 Math.E、Math.sin、Math.pow ......</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token constant">PI</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>备注：通常来说，静态属性我们都使用大写命名，静态方法命名和普通方法命名方式一样。</p><h2 id="instanceof 和面向对象" class="css-1u87juy">instanceof 和面向对象<a href="#instanceof 和面向对象" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>在对象原型的章节，我们介绍过 <code>instanceof</code> 关键字，它被用来判断某个函数的 <code>prototype</code> 是否在某个对象的原型链上。</p><p><strong>在面向对象中，<code>instanceof</code> 可以理解为判断一个对象是否是某个类的实例</strong>，比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">OtherClass</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true ; p 是 Person 类的实例</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">OtherClass</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false ; p 不是 OtherClass 类的实例</span>
</code></pre></div><p>如果面试时，问到 <code>instanceof</code> 关键字的作用你可以从两个方面回答：</p><ul><li>从语法上：<code>instanceof</code> 用来判断函数的 <code>prototype</code> 是否在某个对象的原型链上；</li><li>从面向对象上：<code>instanceof</code> 用来判断一个对象是否是某个类的实例。</li></ul><h2 id="面向对象的特性" class="css-1u87juy">面向对象的特性<a href="#面向对象的特性" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>面向对象有三个基础特性，<strong>封装、继承、多态</strong>。</p><p>也有些其他特性，比如方法 <strong>重写，重载</strong>。</p><p>封装是面向对象的设计方式的一大特点，把数据和它们的行为进行融合，编写到类中，在上一节的例子中，已经介绍 JS 中实现对类封装的方式，再次不再赘述。</p><p>再次强调一下，JS 中没有面向对象语法，一切关于面向对象的知识，都只是模拟，本节课并没有介绍新的语法或 API，只是讲解一种新的设计模式，从本质上来说，面向对象就是一种设计模式。</p><h3 id="继承" class="css-1u87juy">继承<a href="#继承" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>在面向对象的设计中，我们可以把抽象的过程分层，最开始，我们只需要抽象最简单的数据即可。</p><p>比如对人进行初步的抽象：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;name is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>然后我们根据职业的不同，从 <code>Person</code> 类的基础上，派生出学生类的抽象：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Student</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">grade</span> <span class="token operator">=</span> grade<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;name is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>非常明显的可以看到，我们的代码产生了冗余。在面向对象中，基于某个类派生的另一个类，它们之间的关系称作 <strong>继承</strong>。</p><p>在面向对象中，基于原始类派生的类称作子类，原始类称作父类。程序应该让子类继承父类的属性和方法，并执行父类的构造函数来构造子类的实例，从而减少代码的冗余。</p><p>在上述代码中，<code>Student</code> 类应当继承自 <code>Person</code> 类，<code>Student</code> 作为子类，<code>Person</code> 作为父类。在 JS 中，可以使用 <code>call</code> 或 <code>apply</code> 来执行父类的初始化方法：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Student</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Person</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">grade</span> <span class="token operator">=</span> grade<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们使用了一个显式绑定，使用 <code>Person</code> 来处理了一下 <code>Student</code> 内的 <code>this</code> 对象，一个类的属性应该都在其构造函数中被初始化，所以执行父类的构造函数，相当于继承了父类的属性。</p><p>接着我们还需要让子类继承父类的方法，目前 <code>Student</code> 类实例的原型链如下：</p><div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">Student.prototype -&amp;gt;  Object.prototype -&amp;gt; null</code></pre></div><p>因为父类 <code>Person</code> 的方法都存放在 <code>Person.prototype</code> 上，如果需要让 <code>Student</code> 类继承 <code>Person</code> 类的方法，就要在 <code>Student</code> 实例的原型链上增加 <code>Person.prototype</code>，让 <code>Student</code> 实例的原型如下：</p><div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">Student.prototype -&amp;gt; Person.prototype -&amp;gt; Object.prototype -&amp;gt; null</code></pre></div><p>很明显，只要改变 <code>Student.prototype</code> 的原型为 <code>Person.prototype</code> 即可，最简单的方式就是：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">setPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// or</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span>
</code></pre></div><p>但是以上方式并不是很好的实现，原型的动态修改会降低 JS 性能，同时，<code>setPrototypeOf</code> 不支持老版本浏览器，<code>__proto__</code> 又是非标准的实现，不是所有浏览器都支持，基于这些原因，实际开发中 JS 没有使用上述方式来继承父类的方法，更换以下方式实现：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> birth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">birth</span> <span class="token operator">=</span> birth<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;name is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">constructor</span> <span class="token operator">=</span> <span class="token maybe-class-name">Student</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Student</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> birth<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Person</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> birth<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">grade</span> <span class="token operator">=</span> grade<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>new Person()</code> 得到一个原型指向 <code>Person.prototype</code> 的对象，用这个对象作为 <code>Student.prototype</code>。因为每个函数的 <code>prototype</code> 都有一个 <code>constructor</code> 属性指向自身，所以需要修复。这样我们就实现了 <code>Student</code> 实例对 <code>Person</code> 方法的继承。</p><p>上面代码中，<code>Student</code> 类实例的原型链如下：</p><div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">Student.prototype(new Person 得来) -&amp;gt; Person.prototype -&amp;gt; Object.prototype -&amp;gt; null</code></pre></div><p>这种继承方式被称作 <strong>寄生式组合继承</strong>，这是 JS 中最常见和使用最广泛的继承方式。</p><p>现在 <code>Student</code> 的实例继承 <code>Person</code> 类的属性，也继承 <code>Person</code> 类的方法，比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> ming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;明&quot;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token string">&quot;一年级&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ming<span class="token punctuation">.</span><span class="token method function property-access">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#x27;name is 明&#x27;</span>
</code></pre></div><p>上述代码中，<code>Student</code> 的实例执行了父类的 <code>say</code> 方法，<code>say</code> 方法内也访问父级定义的 <code>name</code> 属性。自此，我们在 JS 中完成了类的继承。</p><p>但是上述继承方式，有一个比较大的缺陷是，<code>Student.prototype</code> 是使用 <code>new</code> 关键字修饰 <code>Person</code> 得来的，<code>new Person()</code> 的执行了 <code>Person</code> 内部逻辑，于是会产生一定程度的副作用，。</p><p>在程序最后打印 <code>Student.prototype</code> 会得到一个奇奇怪怪的值：</p><div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">Person {name: undefined, birth: undefined, constructor: ƒ}</code></pre></div><p>很容易理解，<code>new Person</code> 时我们没有传入参数，<code>name</code> 和 <code>birth</code> 为 <code>undefined</code>，内部的空对象绑定了这两个属性。把上面的对象记作 A，目前 <code>Student</code> 实例的原型就是 A，它的原型链是：</p><div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">A -&amp;gt; Person.prototype -&amp;gt; Object.prototype -&amp;gt; null</code></pre></div><p>A 会作为所有 <code>Student</code> 类实例的原型，<code>name</code> 和 <code>birth</code> 属性是我们使用 <code>new Person</code> 带来的副作用，如果 <code>Person</code> 函数中有其他影响巨大的副作用，比如定时器等：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> birth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">birth</span> <span class="token operator">=</span> birth<span class="token punctuation">;</span>
  <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;do something&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时使用 <code>new Person</code> 作为 <code>Student.prototype</code> 的话，程序就会多余执行一个定时器，可以使用以下方式来消除父类执行时的副作用：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">SpacePerson</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">SpacePerson</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpacePerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">constructor</span> <span class="token operator">=</span> <span class="token maybe-class-name">Student</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码中，我们声明了一个空函数，来代替 <code>Person</code> ，把 <code>SpacePerson.prototype</code> 指向 <code>Person.prototype</code>，<code>new SpacePerson</code> 就不会有任何副作用，相当于抹去了 <code>Person</code> 函数的内部执行。此时，<code>Student</code> 实例的原型链就为：</p><div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">Student.prototype(new SpacePerson 得来) -&amp;gt; Person.prototype -&amp;gt; Object.prototype -&amp;gt; null</code></pre></div><p>现在我们把封装的代码封装起来：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">SubClass</span><span class="token punctuation">,</span> <span class="token maybe-class-name">SuperClass</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token class-name">SuperClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">constructor</span> <span class="token operator">=</span> <span class="token maybe-class-name">SubClass</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在使用 <code>_inherit</code> 函数来实现继承：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">SubClass</span><span class="token punctuation">,</span> <span class="token maybe-class-name">SuperClass</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token class-name">SuperClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">constructor</span> <span class="token operator">=</span> <span class="token maybe-class-name">SubClass</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> birth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">birth</span> <span class="token operator">=</span> birth<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;name is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token maybe-class-name">Student</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Student</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> birth<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Person</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> birth<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">grade</span> <span class="token operator">=</span> grade<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述继承方式依旧是寄生式组合继承，只是重新进行了封装。</p><p>寄生式组合继承的原则是以下两点：</p><ul><li><strong>子类的构造函数内执行父类的构造函数</strong></li><li><strong>子类实例的原型链上继承了父类的方法</strong></li></ul><p>关于第一条，只要在子类的构造函数中，使用 <code>SuperClass.call(this,...)</code> 就可以实现，第二条我们使用了 <code>_inherit</code> 函数封装实现，根据定义，<code>_inherit</code> 的实现方式有多种：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token comment">// 使用 `new` 关键字</span>
<span class="token keyword">function</span> <span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">SubClass</span><span class="token punctuation">,</span> <span class="token maybe-class-name">SuperClass</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token class-name">SuperClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">constructor</span> <span class="token operator">=</span> <span class="token maybe-class-name">SubClass</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用 Object.create 低版本浏览器不兼容</span>
<span class="token keyword">function</span> <span class="token function">_inherit2</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">SubClass</span><span class="token punctuation">,</span> <span class="token maybe-class-name">SuperClass</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">create</span><span class="token punctuation">(</span><span class="token class-name">SuperClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">constructor</span> <span class="token operator">=</span> <span class="token maybe-class-name">SubClass</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 直接设置原型，会降低运行效率</span>
<span class="token keyword">function</span> <span class="token function">_inherit3</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">SubClass</span><span class="token punctuation">,</span> <span class="token maybe-class-name">SuperClass</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">setPrototypeOf</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">setPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">,</span> <span class="token class-name">SuperClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">__proto__</span> <span class="token operator">=</span> <span class="token class-name">SuperClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用以上的函数都可以在 JS 中完成类方法的继承。</p><p>对寄生式组合继承简化后，如下：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 方法继承</span>
<span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token maybe-class-name">Student</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Student</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 父类构造函数访问</span>
  <span class="token maybe-class-name">Person</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>子类会继承父类属性和方法，同时子类可以添加新的属性或新的方法。</p></blockquote><h3 id="多重继承" class="css-1u87juy">多重继承<a href="#多重继承" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>面相对象中，类与类的继承呈现为链式，比如类 C 继承类 B，类 B 又继承类 A，比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token parameter"><span class="token maybe-class-name">SubClass</span><span class="token punctuation">,</span> <span class="token maybe-class-name">SuperClass</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token class-name">SuperClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">;</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">SubClass</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">constructor</span> <span class="token operator">=</span> <span class="token maybe-class-name">SubClass</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义动物类</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Animal</span></span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> birth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">=</span> type<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">birth</span> <span class="token operator">=</span> birth<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token maybe-class-name">Person</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 定义人类</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> birth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Animal</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;Person&quot;</span><span class="token punctuation">,</span> birth<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token maybe-class-name">Student</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 定义学生类</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Student</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> birth<span class="token punctuation">,</span> school<span class="token punctuation">,</span> classroom</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Person</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> birth<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">school</span> <span class="token operator">=</span> school<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">classroom</span> <span class="token operator">=</span> classroom<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">birth</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">school</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">classroom</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> ming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;2015-01-01&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;xx小学&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;三年二班&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ming<span class="token punctuation">.</span><span class="token method function property-access">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，<code>Person</code> 类中，我们访问 <code>Animal</code> 类的构造函数时，直接传递了类型，所以可以在参数列表中简化 <code>type</code> 参数。</p><h3 id="方法重载" class="css-1u87juy">方法重载<a href="#方法重载" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>在某些语言中，一个方法可以被定义多次，由它们的参数规则来区分如何调用。</p><p>比如：</p><div class="remark-highlight"><pre class="language-unknown"><code class="language-unknown">// 伪代码
class Compute {
  method add (a, b) {
    return a + b;
  }
  method add (a, b, c) {
    return a + b + c;
  }
}

a = new Math();
a.add(1,2); // 3
a.add(1,2,3); // 6</code></pre></div><p>类似上面的伪代码，我们定义了一个类 <code>Compute</code>，它有两个同名方法 <code>add</code> ，当我们调用 <code>add</code> 方法的时候，根据传入的参数不同，程序引擎会自动识别，然后选择符合条件的那个执行。</p><p>这种 <strong>在同一个类中，同一个方法，因参数不同重复声明的行为被称作方法重载</strong>。</p><p>JS 中没有重载，同一个方法重复声明会被覆盖，因为我们是用 JS 对象属性来模拟方法的。如下：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Compute</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token maybe-class-name">Compute</span><span class="token punctuation">.</span><span class="token property-access">prorotype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token maybe-class-name">Compute</span><span class="token punctuation">.</span><span class="token property-access">prorotype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>上述代码中，第二次对 <code>add</code> 方法的定义会被覆盖，因为在 JS 中 <code>prototype.add</code> 只是一个普通的对象属性。</p><p>在 JS 中，方法重载需要程序员手动实现：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Compute</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Compute</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">_add1</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">_add2</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> _add1<span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> _add2<span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword module">default</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> comp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
comp<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
comp<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
</code></pre></div><p>上述代码中，我们自己判断了参数个数，实现了方法的重载。【代码解释】</p><p>上面是一种简单的实现重载的方式，通过参数数量来判断，<strong>方法重载并不一定只是参数数量不同，也有可能是参数数量相同，但是参数类型不同</strong>，需要根据不同的重载来编写不同的分支。</p><p>因为在 JS 中重载是被我们自己实现的，所以重载并不局限于类的方法中，普通函数也可以实现重载。如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">_add1</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">_add2</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">switch</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span><span class="token property-access">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> _add1<span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> _add2<span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword module">default</span><span class="token operator">:</span>
      <span class="token keyword control-flow">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
</code></pre></div><p><strong>小结：在同一个类中，重复定义一个方法，参数的类型或数量不同，这种情况才被称作重载。JS 中的方法重载是手动实现的，所以方法重载的思维还可以用到普通函数中。</strong></p><h3 id="方法重写" class="css-1u87juy">方法重写<a href="#方法重写" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>面向对象中还有另一种重复声明方法的方式 <strong>重写</strong>，重写定义如下：子类继承父类，子类重新定义父类的方法，并且参数和父类的方法完全相同。</p><p>为什么会有重写？可以看如下例子：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token comment">// 鸟类</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Bird</span></span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">=</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Bird</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">fly</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">+</span> <span class="token string">&quot;会飞&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 企鹅类</span>
<span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token maybe-class-name">Penguin</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Bird</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Penguin</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Bird</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;企鹅&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token maybe-class-name">Penguin</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Penguin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token maybe-class-name">Penguin</span><span class="token punctuation">.</span><span class="token method function property-access">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 企鹅会飞</span>
</code></pre></div><p>企鹅虽然属于鸟类，但是企鹅被不会飞行，如果 <code>Penguin</code> 类不重新定义父类的 <code>fly</code> 方法，那就会出现一些预料之外的行为。</p><p>关于上述例子，我们需要重新定义 <code>Penguin</code> 类的 <code>fly</code> 方法：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token class-name">Penguin</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">fly</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">type</span> <span class="token operator">+</span> <span class="token string">&quot;并不会飞&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>重写并不是都像上面一样否定父类方法，也可能是扩展父类方法，比如：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 自我介绍</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">desc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;我叫&quot;</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token maybe-class-name">Student</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Student</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> school<span class="token punctuation">,</span> classroom</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Person</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">school</span> <span class="token operator">=</span> school<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">classroom</span> <span class="token operator">=</span> classroom<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 重写自我介绍</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">desc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;我叫&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">+</span> <span class="token string">&quot;，来自&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">school</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">classroom</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> ming <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;xx小学&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;三年二班&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ming<span class="token punctuation">.</span><span class="token method function property-access">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在上面代码中，<code>Student</code> 类重写了 <code>desc</code> 方法，扩展了父类 <code>desc</code> 方法的功能。</p><p><strong>小结：重写方法必须和父类方法的参数列表相同，重写可能是修正父类方法，也可能是扩展父类方法。</strong></p><h3 id="多态" class="css-1u87juy">多态<a href="#多态" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3><p>多态是面向对象的一大特色，字面意思就是多种状态，指的主要是类中方法的多种状态。</p><p>多态产生的条件：</p><ul><li>继承</li><li>子类重写父类方法</li><li>父类引用子类对象</li></ul><p>前两个条件我们已经实现了，关键是第三个条件的理解。</p><p>观察以下代码：</p><div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Person</span></span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 自我介绍</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">desc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;我叫&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token maybe-class-name">Student</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Student</span></span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Person</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">grade</span> <span class="token operator">=</span> grade<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">desc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;我叫&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">+</span> <span class="token string">&quot;，是一名学生，今年上&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">grade</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">_inherit</span><span class="token punctuation">(</span><span class="token maybe-class-name">Dirver</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Dirver</span></span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token maybe-class-name">Person</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Dirver</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">desc</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;我叫&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">+</span> <span class="token string">&quot;，是一个司机&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">doDesc</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span><span class="token method function property-access">desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">doDesc</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;三年级&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 我叫foo，是一名学生，今年上三年级</span>
<span class="token function">doDesc</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dirver</span><span class="token punctuation">(</span><span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 我叫bar，是一个司机</span>
</code></pre></div><p>在上述代码中，<code>Student</code> 类和 <code>Dirver</code> 类都继承自 <code>Person</code> 类，并且重写的 <code>desc</code> 方法，完成了多态的前两个条件。</p><p>从面向对象的角度观察 <code>doDesc</code> 函数，我们判断传入的对象是否是 <code>Person</code> 的实例，如果是，执行 <code>Person</code> 类的 <code>desc</code> 方法。</p><p>但是我们后来传入了 <code>Student</code> 类和 <code>Dirver</code> 类的实例，它们被顺利执行了。在 <code>doDesc</code> 函数中，程序基于 <code>Person</code> 类引用了其子类实例的 <code>desc</code> 方法，它满足了多态的第三个条件，父类引用子类实例。</p><p>最后的结果也显而易见，父类的 <code>desc</code> 方法在子类中的不同形态得以表现，这就是面向对象的多态。</p><p>多态常被用来在父类方法的基础上做出一定的修改，或者将某些行为插入到父类中。</p><p><strong>需要注意的是，方法重载和多态并没有关系。</strong></p><h2 id="总结" class="css-1u87juy">总结<a href="#总结" class="css-17vkerv"><svg xmlns="http://www.w3.org/2000/svg" width="0.8em" height="0.8em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" color="inherit"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2><p>在 JS 中，并不支持面向对象开发，在 JS 中，只能基于 JS 原始的特性和语法模拟面向对象开发。面向对象是一种设计模式，使用面向对象的思维来抽象实际问题大部分情况下，都可以起到事半功倍的效果。</p><ul><li><p>在面向对象中</p><ul><li><p>类就像实际问题的设计图</p></li><li><p>事物的数据信息和行为被抽象成来了类的属性和方法</p></li><li><p>属于类的属性和方法称作静态属性与静态方法</p></li><li><p>基于某个类生成的对象被称作这个类的实例</p></li><li><p>类的方法有重载和重写特性</p><ul><li>同一个类中，可能存在参数不同的同名方法，这种重复声明的方式称作重载</li><li>子类可以重新定义父类方法，参数必须相同，这种重复声明的方式称作重写</li></ul></li><li><p>面向对象有三大特性：封装、继承、多态</p><ul><li>面向对象开发，会基于对象本身，把它的数据和行为封装到一个类中，面向对象提供非常好的封装性</li><li>基于一个类的派生的类，它们存在继承关系。在面向对象中，可以让派生出的类继承自原始类，子类会继承父类的属性和方法（不会继承父类的静态属性和静态方法）</li><li>多态是指父类方法在不同子类中得以不同形态的展现。</li></ul></li></ul></li><li><p>在 JS 中</p><ul><li><p>使用函数来模拟类，用来模拟类的函数也叫作类的构造函数。</p></li><li><p>使用对象属性来模拟类的属性，在构造函数的 <code>prototype</code> 上定义函数来模拟类的方法</p></li><li><p>类的实例使用 <code>new</code> 关键字修饰函数执行得到</p></li><li><p>方法重载需要主动实现</p></li><li><p>方法重写依靠原型链的属性屏蔽</p></li><li><p>类的继承基于对父类构造函数的调用和原型链的委托（这里单指寄生式组合继承）</p></li><li><p>实例与类的关系使用 <code>instanceof</code> 关键字的结果模拟</p></li></ul></li></ul></article></div></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/js/面向对象/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-da8157b780a7e1fd9e9e.js"],"app":["/app-38218a2ef72326a75367.js"],"component---src-pages-404-js":["/component---src-pages-404-js-f91e86cfe65092e3adc1.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-57b3b630e72243cc3df9.js"],"component---src-templates-docs-tsx":["/component---src-templates-docs-tsx-3f6722c11400634ddec5.js"]};/*]]>*/</script><script src="/jnet-basic-v2/polyfill-da8157b780a7e1fd9e9e.js" nomodule=""></script><script src="/jnet-basic-v2/component---src-templates-docs-tsx-3f6722c11400634ddec5.js" async=""></script><script src="/jnet-basic-v2/1512ff2dbf77859a0dcbee24710e2018e282937f-369ee37846485c1e14f7.js" async=""></script><script src="/jnet-basic-v2/app-38218a2ef72326a75367.js" async=""></script><script src="/jnet-basic-v2/framework-e8e53ba50a7a1b0850f7.js" async=""></script><script src="/jnet-basic-v2/webpack-runtime-a52939d631f5cc604aea.js" async=""></script></body></html>