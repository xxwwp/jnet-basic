<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="HTML，CSS，JavaScript 基础知识 " />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.1/styles/agate.css"
      integrity="sha256-kp6wpFoGWDWLARjInqKMjQOa80CoSWr0RGbhXohAh2c="
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"
      integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"
    ></script>
    
<link rel="stylesheet" href="/jnet-basic/css/layout.css">

    <title>JNet Basic</title>
  <meta name="generator" content="Hexo 5.2.0"></head>

  <body>
    <div class="sidebar">
  <aside class="sidebar-toc-page"><!--  -->


<div class="toc-page">
  <div class="toc-page-hd">
    <a href="/jnet-basic/"> JNet Basic </a>
  </div>
  <ul>
    
<li>
  <a href="/jnet-basic/%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/" class="">课程介绍</a>
</li>

<li>
  <span class="label">html_</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/html_/%E6%95%99%E7%BA%B2/" class="">教纲</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E6%A6%82%E8%BF%B0/" class="">概述</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/" class="">基础理论</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%A4%B4%E9%83%A8%E5%AD%A6%E4%B9%A0/" class="">头部学习</a>
</li>

<li>
  <span class="label">元素学习</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%83%E7%B4%A0/" class="">文章相关的元素</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E8%B6%85%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%9B%BE%E7%89%87/" class="">超链接与图片</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E6%97%A0%E8%AF%AD%E4%B9%89%E5%85%83%E7%B4%A0/" class="">无语义元素</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%A0%BC/" class="">表格</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/" class="">表单元素</a>
</li>

</ul>

<li>
  <a href="/jnet-basic/html_/%E5%B1%9E%E6%80%A7/" class="">属性</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E8%A1%A5%E5%85%85%E4%B8%8E%E7%BB%93%E6%9D%9F/" class="">补充与结束</a>
</li>

</ul>

<li>
  <span class="label">css_</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/css_/%E6%95%99%E7%BA%B2/" class="">教纲</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E6%A6%82%E8%BF%B0/" class="">概述</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E9%80%89%E6%8B%A9%E5%99%A8/" class="">选择器</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E5%B1%82%E5%8F%A0%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7/" class="">核心概念-层叠，继承，优先级</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/" class="">盒模型与文档流</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/" class="">文本处理</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E8%A1%A8%E6%A0%BC%E5%A4%84%E7%90%86/" class="">表格处理</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E8%83%8C%E6%99%AF%E5%A4%84%E7%90%86/" class="">背景处理</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E6%9D%82%E9%A1%B9/" class="">杂项</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B1%80/" class="">基础布局</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E5%B8%83%E5%B1%80%E8%BF%9B%E9%98%B6/" class="">布局进阶</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E7%BB%83%E4%B9%A0/" class="">常见布局练习</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E8%A1%A5%E5%85%85%E4%B8%8E%E7%BB%93%E6%9D%9F/" class="">补充与结束</a>
</li>

</ul>

<li>
  <span class="label">js_</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/js_/%E7%9B%AE%E5%BD%95/" class="">目录</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E7%A8%8B%E5%BA%8F%E5%BC%95%E5%AF%BC%E8%AF%BE/" class="">程序引导课</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%9F%BA%E7%A1%80/" class="">基础</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%95%B0%E6%8D%AE%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="">数据、运算符和表达式</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%87%BD%E6%95%B0%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="">函数和作用域</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" class="">引用类型</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="">流程控制</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="">类型判断与类型转换</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/" class="">函数深入</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%B8%B8%E7%94%A8_API/" class="">常用_API</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="">异步编程</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%8F%90%E5%8D%87/" class="">提升</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E9%97%AD%E5%8C%85/" class="">闭包</a>
</li>

<li>
  <a href="/jnet-basic/js_/this_%E5%85%B3%E9%94%AE%E5%AD%97/" class="">this_关键字</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/" class="">对象原型</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="">面向对象</a>
</li>

<li>
  <a href="/jnet-basic/js_/DOM/" class="">DOM</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E4%BA%8B%E4%BB%B6/" class="">事件</a>
</li>

<li>
  <a href="/jnet-basic/js_/BOM/" class="">BOM</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%8A%A0%E8%BD%BD/" class="">渲染与加载</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" class="">错误处理</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" class="">严格模式</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%AD%A3%E5%88%99%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="">正则字符串</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/" class="current">网络简述</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%9D%82%E9%A1%B9/" class="">杂项</a>
</li>

</ul>

<li>
  <a href="/jnet-basic/%E6%80%BB%E7%BB%83%E4%B9%A0/" class="">总练习</a>
</li>

<li>
  <a href="/jnet-basic/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/" class="">课程总结</a>
</li>

<li>
  <a href="/jnet-basic/%E7%B4%A0%E6%9D%90/" class="">素材</a>
</li>

  </ul>
</div>
</aside>
  <aside class="sidebar-toc-article"><div class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%86"><span class="toc-text">网络认识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">本地服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx-%E7%AE%80%E8%BF%B0"><span class="toc-text">nginx 简述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">nginx 常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99"><span class="toc-text">路由规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D"><span class="toc-text">本地域名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLHttpRequest"><span class="toc-text">XMLHttpRequest</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%89%8D"><span class="toc-text">请求前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-text">发送请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94"><span class="toc-text">响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-text">事件绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">XMLHttpRequest 兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></div>
</aside>
</div>
<script>
  $(document).ready(function () {
    var elTocPage = $('.sidebar .sidebar-toc-page').get(0);
    $(elTocPage).on('click', function (elToc) {
      $(this).addClass('show')
    })
    $(document).on('click', function (el) {
      elTocPage.contains(el.target) || $(elTocPage).removeClass('show');
    })
  })
</script>
    <main><article>
  <h1>网络简述</h1>
  <hr />
  <div class="article-bd"><h2 id="网络认识"><a href="#网络认识" class="headerlink" title="网络认识"></a>网络认识</h2><p>每台计算机都独立存在了，当两台计算机通过线路的连接后，它们之间可以互相通信，这就最简单的网络。</p>
<p>全世界最大的网络被称作互联网，互联网上有很多计算机向外提供服务，向外提供服务的计算机被广义上定义为 <mark>服务器</mark>。当我们访问某个网址时，计算机根据网址找到对应的计算机，与其开始通信。</p>
<p>互联网就像一张巨大的蜘蛛网，数据在网中传输，而每台计算机就像蜘蛛网上的节点，网最左边的节点虽然和右边的节点相距甚远，但是总能找到一条线路把它们连接起来。</p>
<p>线路中其他的节点会帮我们传递数据，这个操作被叫做 <mark>路由或代理</mark>。</p>
<p>在互联网中，每台计算机都被指定了一个唯一的地址，这个地址被称作 IP 地址，它指定了计算机在网络中的具体网址。通过 IP 地址我们可以访问任何一台互联网中的计算机，但是前提是对方愿意和我们通信。</p>
<p>在计算机终端中使用 <code>ping</code> 命令可以判断网络中是否有指定 IP 的计算机。在计算机的启动台里搜索终端可以并打开，键入以下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping www.baidu.com<br></code></pre></td></tr></table></figure>

<p>上面代码我们 <code>ping</code> 了百度的网址，它会显示百度网的 IP 地址。这个操作类似于微信里的 “拍一拍”，我们和百度网的服务器打了声招呼。</p>
<p>不同程序之间互相通信通过端口互相连接，如果把 IP 地址比作现实生活中的地址，比如 “北京市 xx 路 120 弄 3 栋 302 号”，那么端口类似于详细的门牌号。其中 “北京市 xx 路 120 弄 3 栋” 就对应一个 IP 地址，这栋楼代表互联网中的一台计算机，楼中每户人家代表不同的程序，而 “302 号” 就指定了某个具体程序，“302 号” 就代表端口号。</p>
<p>剖析一个网络地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">163.177.151.110:80<br></code></pre></td></tr></table></figure>

<p>上面地址表示了 IP <code>163.177.151.110</code> 计算机上运行在 <code>80</code> 端口的程序。你可以在浏览器输入这个地址和端口号，试一试。</p>
<p>此时你也许有点混乱，<code>www.baidu.com</code> 是一个网址，并不是 IP 地址啊，也没有端口号，我们是如何与百度的服务器通信的呢？</p>
<p>这是因为 IP 地址不利于人类记忆，可读性太差，所以网络的上层使用可读的字符串也就是 URL 来表示 IP 地址，<code>www.baidu.com</code> 被称作域名或者主机名，用来替代百度服务器的 IP 地址。域名和 IP 地址直接存在映射关系。在网络中，有一些服务器会专门存储和处理域名和 IP 映射关系，并提供映射关系的查找服务，它们被称作 DNS 服务器。</p>
<p>当我们打开浏览器，键入百度网址时，网络中大致会发生以下过程：</p>
<ol>
<li>浏览器获取网址，现在本机缓存或配置文件中查询这个地址有没有对应的 IP，如果没有继续下一步；</li>
<li>浏览器会把网址发送最近的 DNS 服务器，待 DNS 服务器查寻网址和 IP 的映射关系后，返回具体的 IP 地址；</li>
<li>浏览器得到到真实的 IP 地址后，会对域名和 IP 的映射关系进行缓存，以免重复上述步骤。</li>
<li>接着浏览器会把 IP 配上具体的端口号，把数据扔到互联网中。互联网的用来通信的计算机会把数据转发到指定 IP 的计算机，然后这台计算机又通过端口号把数据发送给指定的程序，这个程序就是服务器程序；</li>
<li>服务器会按照相同的方式返回数据包，浏览器会在获取到数据后进行解析，如果是 HTML 数据，就渲染展示。</li>
</ol>
<h2 id="本地服务器"><a href="#本地服务器" class="headerlink" title="本地服务器"></a>本地服务器</h2><p>上一节我们简单介绍了数据如何在网络中通信，并了解浏览器与服务器的通信实际是两台计算机不同程序的通信。在开发时，我们一般不会使用多台计算机开发，所以会把服务器和浏览器都安装在同一台计算机上，这种服务器被称作本地服务器。这种方式简化了数据在网络中传输，而是直接在当前计算机的两个程序中传输。</p>
<p>它的工作方式大概是：</p>
<p>首先在我们的计算机中安装服务器和浏览器，然后开启服务器，并监听某个端口，比如 80 端口，接着在浏览器中输入 <code>127.0.0.1:80</code> 这个地址，<code>127.0.0.1</code> 是一个特殊的 IP 地址，它指向当前计算机，被称作 <mark>环回地址</mark>。接着会发生以下过程：</p>
<ol>
<li>浏览器向 <code>127.0.0.1:80</code> 地址发送数据包；</li>
<li>计算机发现这个地址是环回地址，于是直接发送给本机运行在 <code>80</code> 端口的程序。</li>
<li>运行在 <code>80</code> 端口的程序是我们本地服务器，本地服务器解析浏览器发送的数据包后，返回相应的数据；</li>
<li>浏览器获取到本地服务器返回的数据包，解析后渲染展示。</li>
</ol>
<p>这个过程被简化了非常多，至少我们不用去访问互联网了，家里断网时，也不影响开发。</p>
<h2 id="nginx-简述"><a href="#nginx-简述" class="headerlink" title="nginx 简述"></a>nginx 简述</h2><p>nginx 是一个服务器软件，它是目前主流的 web 服务器软件，它有一个劲敌是 Apache，但是 Apache 不够简便，不适合新手操作。这一小节我们将使用 nginx 搭建一个本地 web 服务器，它的操作非常简单，安装启动即可。</p>
<p><a target="_blank" rel="noopener" href="http://nginx.org/en/download.html">点此</a> 获取 nginx 的下载链接，下载 Stable version（稳定版本）。不同的系统下载不同版本的包，不要下错。</p>
<p>因为我使用的是 windows 系统，十分抱歉无法演示 mac 系统的安装过程。</p>
<p>nginx 的安装包是一个压缩包，直接解压即可，包中会有一个 nginx.exe 文件，双击即可启动。nginx 默认会运行在 <code>80</code> 端口上，打开浏览器，键入 <code>127.0.0.1:80</code> 即可访问我们自己的 nginx 服务器。</p>
<p><code>:80</code> 是 web 服务器的默认端口，它会在访问后消失自动省略，如果是 nginx 运行在 <code>:9999</code> 这样的其他端口就不能省略。</p>
<h3 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h3><p>在 nginx 的文件夹中摁下 【shift + 鼠标右键】，点击【在此打开 Powershell 窗口】即可在这个文件夹中打开终端。</p>
<p>nginx 并有可视化窗口给我们控制，关闭或重启 nginx 都需要依靠命令，nginx 常用命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>.\nginx.exe -s quit</code></td>
<td>等所有连接结束后，关闭 nginx 程序</td>
</tr>
<tr>
<td><code>.\nginx.exe -s stop</code></td>
<td>直接关闭 nginx 程序</td>
</tr>
<tr>
<td><code>.\nginx.exe -s reload</code></td>
<td>重启 nginx 程序</td>
</tr>
<tr>
<td><code>.\nginx.exe -h </code></td>
<td>获取帮助</td>
</tr>
</tbody></table>
<h3 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h3><p>当通过浏览器访问 nginx 时，地址栏的路径会和 html 文件夹内的文件做映射关系，比如：</p>
<table>
<thead>
<tr>
<th>浏览器地址</th>
<th>对应 html 内的文件</th>
</tr>
</thead>
<tbody><tr>
<td><code>127.0.0.1/index.html</code></td>
<td><code>html/index.html</code></td>
</tr>
<tr>
<td><code>127.0.0.1/style.css</code></td>
<td><code>html/style.css</code></td>
</tr>
<tr>
<td><code>127.0.0.1/page/one.html</code></td>
<td><code>html/page/one.html</code></td>
</tr>
<tr>
<td><code>127.0.0.1</code></td>
<td><code>html/index.html</code></td>
</tr>
<tr>
<td><code>127.0.0.1/page</code></td>
<td><code>html/page/index.html</code></td>
</tr>
</tbody></table>
<p>nginx 会有限按照地址路径查询文件，如果查询失败，会尝试在路径后添加 <code>/index.html</code> 来再次查询，如果都查询失败，返回一个 404 页面。</p>
<h3 id="本地域名"><a href="#本地域名" class="headerlink" title="本地域名"></a>本地域名</h3><p><code>127.0.0.1</code> 不便于书写，在计算机中，有一个本地主机名和它有相同的作用，<code>localhost</code>。可以使用 <code>localhost</code> 来代替 <code>127.0.0.1</code>。在浏览器地址栏输入 <code>localhost</code> 单击回车，也可以访问本地 nginx 服务器。</p>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>目前为止，我们的页面都是一次性加载，需要获取或者发送数据都需要刷新页面。AJAX （Asynchronous JavaScript And XML ，异步脚本）技术可以用于在页面不刷新的情况下，向网络中收发数据。在 JS 中，使用 <code>XMLHttpRequest</code> 函数来实现 AJAX。</p>
<p>在网络中，客户端向服务器发送的数据称作 <strong>请求报文</strong>，服务器针对请求返回的数据称作 <strong>响应报文</strong>，使用 <code>XMLHttpRequest</code> 函数可以让 JS 向网络中发送请求和接收响应。</p>
<p>在 nginx 的 html 文件夹创建文件 <code>data.txt</code> 如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">一段数据信息。<br></code></pre></td></tr></table></figure>

<p>然后在 <code>html/index.html</code> 中编写以下程序：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bt&quot;</span>&gt;</span>发送请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>响应数据为：<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;res&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> btEl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;bt&quot;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> resEl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;res&quot;</span>);</span><br><span class="javascript">  btEl.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-comment">// 获取 XMLHttpRequest 实例</span></span><br><span class="javascript">    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><br><span class="javascript">    <span class="hljs-comment">// 设置数据传输方法和地址，类似 form 元素的 method 和 action 属性</span></span><br><span class="javascript">    xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;http://localhost/data.txt&quot;</span>);</span><br><span class="javascript">    <span class="hljs-comment">// 设置请求结束时的回调</span></span><br><span class="javascript">    xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-comment">// 获取响应数据并展示到页面上</span></span><br>      resEl.innerText = e.target.response;<br>    &#125;;<br><span class="javascript">    <span class="hljs-comment">// 发送请求</span></span><br>    xhr.send();<br>  &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>上面代码中，再点击【发送请求】按钮后，程序发送了一个简单的网络请求，并且把响应的数据放到了页面中。这个网络请求中，nginx 充当了我们的后端服务器，它解析地址 <code>http://localhost/data.txt</code> 后发现是一个文件，于是读取这个文件的内容作为响应数据。</p>
<p>实际开发中，我们的请求一般由后端人员处理，后端人员会根据请求的信息，发送合适的响应。nginx 服务器是一个静态资源服务器，它只处理 <code>GET</code> 方法的请求，遇到无法解析的地址，它会返回错误。比如修改上面请求的地址，nginx 会给我返回一个 404 数据包。</p>
<p>请求的数据包可以在控制台的 Network 模块查看，它详细描述了每个请求与响应的信息。</p>
<h3 id="请求前"><a href="#请求前" class="headerlink" title="请求前"></a>请求前</h3><p>在建立连接时，我们可以设置请求报文的相关信息，请求报文由 <strong>起始行</strong> 、<strong>首部</strong> 和 <strong>主体</strong> 三部分组成，起始行包含了请求方法，地址和使用协议。首部包含了请求报文的详细信息，比如数据的格式，请求的主机，设置的安全规则等等，这些信息被称作 <strong>头信息</strong>。最后一条头信息会连续换行两次，之后的内容为主体数据，一般情况下，GET 方法的请求不设置主体数据。</p>
<p>可以打开控制台的 Network 模块，然后选择一个数据包，依次点击【Headers】 -&gt; 【Reqeust Headers】 -&gt; 【view source】查看完成的数据包头源码。它大概长这样：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/data.txt</span> HTTP/1.1<br><span class="hljs-attribute">Host</span>: localhost<br><span class="hljs-attribute">Connection</span>: keep-alive<br><span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36<br><span class="hljs-attribute">Accept</span>: */*<br><span class="hljs-attribute">Sec-Fetch-Site</span>: same-origin<br><span class="hljs-attribute">Sec-Fetch-Mode</span>: cors<br><span class="hljs-attribute">Sec-Fetch-Dest</span>: empty<br><span class="hljs-attribute">Referer</span>: http://localhost/<br><span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate, br<br><span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.9,en;q=0.8<br><br></code></pre></td></tr></table></figure>

<p>其中，第一行是起始行，它的意思是使用 <code>GET</code> 方法请求 <code>/data.txt</code> 地址，使用的网络协议是 <code>HTTP/1.1</code>。</p>
<p>除去第一行的信息，后面的信息都统称为头信息，它们的格式都是键值对 key:value 的形式，它们都有各自不同的功能，比如 <code>Host</code> 描述了请求的域名是 <code>localhost</code>，<code>User-Agent</code> 描述了用户代理信息，这些信息作用于不同模块，在此不多介绍。</p>
<p>打开网络连接后到发送数据钱，可以使用 <code>XMLHttpRequest</code> 实例的以下属性和方法：</p>
<ul>
<li><p><code>open</code> 方法：用于打开一个网络连接，它会发送请求报文的起始行，比如 <code>GET /data.txt HTTP/1.1</code>。它有两个必要参数和三个可选参数：</p>
<ul>
<li><code>method</code>：设置数据包的方法，比如 <code>GET</code> 或 <code>POST</code>（nginx 只能接收 get 方法）。</li>
<li><code>url</code>：设置数据包发送的地址。</li>
<li><code>async</code>：可选，默认为 <code>true</code>，表示设置是否异步发送数据，如果同步的话，请求后面的 JavaScript 代码会被挂起，要等到请求结束才能执行，一般不会设置同步请求。</li>
<li><code>username</code>: 可选，设置请求时使用的账户名，web 服务器使用不到</li>
<li><code>password</code>: 可选，设置请求时使用的密码，web 服务器使用不到</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">// 异步请求</span><br>xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/data.text&quot;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>setRequestHeaders</code> 方法：用于设置数据包的头信息，它有两个参数，使用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/data.text&quot;</span>);<br>xhr.setRequestHeader(<span class="hljs-string">&quot;something&quot;</span>, <span class="hljs-string">&quot;eeeeeeeeeeeee&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>在发送上面数据包后打开控制台，可以看到头信息设置成功了。需要记住，这个方法必须在 <code>send</code> 之前使用。</p>
</li>
<li><p><code>timeout</code> 属性：设置请求的超时时间，单位是毫秒，如果超出 <code>timeout</code> 的值，那么就视为请求超时。默认值为 0，表示永不超时。</p>
</li>
<li><p><code>ontimeout</code> 方法：设置请求超时的事件，请求超时后触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.timeout = <span class="hljs-number">2000</span>; <span class="hljs-comment">// 超过 2 秒就算超时，触发 ontimeout 事件，可以设置为 1 毫秒，就很容易发生超时</span><br>xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;请求超时&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>readyState</code> 只读属性：</p>
<p>返回一个数字，对应请求的状态。各个数字的对应状态为：</p>
<table>
<thead>
<tr>
<th><code>readyState</code></th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><code>XMLHttpRequest.UNSEND</code>，数据未发送。</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>XMLHttpRequest.OPENED</code>，<code>open</code> 方法调用后改变，此时网络连接已经建立。</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>XMLHttpRequest.HEADERS_RECEIVED</code>，<code>send</code> 方法调用后改变，此时服务器已经接受到数据包的头信息，数据部分还未接收完毕。</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>XMLHttpRequest.LOADING</code>，服务器开始接收数据时改变，服务器正在接收数据或者处理数据包，这个过程可能很长，如果是上传或下载文件，那么这个状态就表示正在上传或者下载，文件很大的话，会持续很长时间。</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>XMLHttpRequest.DONE</code>，服务器响应数据后改变，此时整个请求已结束，数据也都全部获得</td>
</tr>
</tbody></table>
</li>
<li><p><code>onreadystatechange</code> 方法：设置 <code>readyState</code> 属性改变时的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(xhr.readyState);<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>onload</code> 方法：设置请求结束时的事件，在 <code>readyState</code> 为 <code>4</code> 时触发。</p>
</li>
<li><p><code>onprogress</code> 方法：监听网络连接的传输进度，一般用于上传或者下载，它对应的事件对象为 <code>ProgressEvent</code>，<code>ProgressEvent</code> 事件对象有三个属性用于获取进度：</p>
<table>
<thead>
<tr>
<th><code>ProgressEvent</code> 属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>lengthComputable</code></td>
<td>一个布尔值，判断当前进度是否可以计算</td>
</tr>
<tr>
<td><code>loaded</code></td>
<td>一个数字，表示已经传输数据量</td>
</tr>
<tr>
<td><code>total</code></td>
<td>一个数字，表示总共的数据量</td>
</tr>
</tbody></table>
<p>可以使用以下方式监听传输进度：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (e.lengthComputable) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;传输进度为：&quot;</span> + (e.loaded / e.total) * <span class="hljs-number">100</span> + <span class="hljs-string">&quot;%&quot;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>本地测试时，可以增加 <code>data.txt</code> 文件的数据，然后在控制台的 Network 模块设置一个较慢网速，之后清除浏览器缓存后测试。</p>
<p><strong>备注：<code>onprogress</code> 不兼容 IE 浏览器。</strong></p>
</li>
</ul>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>当一切准备就绪，我们就可以发送一个请求了，<code>XMLHttpRequest</code> 对象使用 <code>send</code> 方法发送请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.send();<br></code></pre></td></tr></table></figure>

<p><code>send</code> 方法接受一个参数用于发送主体数据，但是不适用于 GET 方式的请求，<mark>GET 方法的请求语义为获取数据</mark>，标准中约定 GET 方法不在主体部分发送数据。浏览器遵守这个约定，所以 GET 方法的请求即便设置主体数据，浏览器也不会处理。</p>
<p>在 HTML 的表单课程我们介绍过，使用 GET 方法传输数据时，数据放在传输地址上，在 AJAX 中发送 GET 请求时，GET 的发送数据可以直接在 <code>open</code> 方法中就设置，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/data.txt/?one=1&amp;tow=2&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>打开控制台，你会发现数据被放到了数据包的起始行。这就是 GET 请求时传输数据的特点，直接放到数据包的起始行。</p>
<p>POST 请求传输数据也不难，但是 nginx 不会处理 POST 请求，所以无法使用 nginx 演示，可以到 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/example-form-submit-oz0ix?file=/src/index.html">这个沙箱</a> 中测试，这是我们在 HTML 学习时介绍表单提交使用的沙箱（需要登录 codesandbox，无法使用的同学可以查看课程 HTML 的 form 元素介绍），这个沙箱用来请求的地址是 <code>/send</code>，任意方法都可以。</p>
<p>打开沙箱，编写以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> resEl = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;/send&quot;</span>);<br>xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  resEl.innerText = xhr.response;<br>  <span class="hljs-built_in">document</span>.body.appendChild(resEl);<br>&#125;;<br>xhr.send(<span class="hljs-string">&quot;asd=123&amp;zxc=123&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>你会发现我们打印了 POST 请求的响应数据。</p>
<p>当使用 POST 发送数据的时候，因为 POST 可以发送多种数据格式，比如图片、视频，如果不加以说明，后端人员就会难以辨别，浏览器也不知道如何处理发送的数据，所以我们要为传输的数据设置数据格式，数据格式使用 <code>Content-Type</code> 头信息设置，基于上面的代码，在 <code>open</code> 方法下面添加以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><code>application/x-www-form-urlencoded</code> 数据格式我们在 HTML 的表单提交章节介绍过，它的格式和 GET 参数的格式一样。</p>
<p>AJAX 中，POST 请求的数据的常用格式是 <code>application/json</code>，也就是 JSON 字符串格式。使用 JSON 格式可以很容易的传输复杂的数据，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> resEl = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;/send&quot;</span>);<br>xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  resEl.innerText = xhr.response;<br>  <span class="hljs-built_in">document</span>.body.appendChild(resEl);<br>&#125;;<br><br><span class="hljs-keyword">var</span> data = &#123;<br>  name: <span class="hljs-string">&quot;data&quot;</span>,<br>  list: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>  bool: <span class="hljs-literal">false</span>,<br>&#125;;<br><br>xhr.send(<span class="hljs-built_in">JSON</span>.stringify(data));<br></code></pre></td></tr></table></figure>

<p>后端人员根据 <code>Content-Type</code> 头信息了解到数据格式是 JSON，他们也会使用类似 <code>JSON.parse</code> 的函数解析 JSON 字符串，从而得到复杂的数据格式。</p>
<p><strong>网络数据包中，POST 数据被放在了哪里？</strong></p>
<p>在 POST 请求时，数据放在了请求报文的主体部分，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/send</span> HTTP/1.1<br><span class="hljs-attribute">Content-Length</span>: 11<br><span class="hljs-attribute">Content-type</span>: application/x-www-form-urlencoded<br>......<br><span class="hljs-attribute">Origin</span>: http://localhost<br><br>one=1&amp;tow=2<br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/send</span> HTTP/1.1<br><span class="hljs-attribute">Content-Length</span>: 45<br><span class="hljs-attribute">Content-type</span>: application/json<br>......<br><span class="hljs-attribute">Origin</span>: http://localhost<br><br>&#123;&quot;name&quot;:&quot;data&quot;,&quot;list&quot;:[1,2,3,4],&quot;bool&quot;:false&#125;<br></code></pre></td></tr></table></figure>

<p>在最后的头信息发送结束后，会连续发送两个换行，表示后面都是数据部分。</p>
<p><strong>终止请求：<code>abort</code> 方法</strong></p>
<p>如果在请求的过程中，需要停止当前终止当前请求继续发送，可以使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听终止请求事件</span><br>xhr.onabort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;请求被终止了。&quot;</span>, xhr);<br>&#125;;<br><span class="hljs-comment">// 终止请求</span><br>xhr.abort();<br></code></pre></td></tr></table></figure>

<p>被终止的请求其 <code>readyState</code> 状态是 0，状态码 <code>status</code> 也会是 0。</p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>在服务器接收到请求数据包后，也会发送一个响应报文作为回复，响应数据包和请求数据包类似，也具有起始行、头信息和主体。可以在控制台的 Network 模块中选择一个数据包，依次点击【Headers】 -&gt; 【Response Headers】 -&gt; 【view source】查看响应报文。</p>
<p>一个响应数据包如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Server</span>: nginx/1.18.0<br><span class="hljs-attribute">Date</span>: Tue, 08 Dec 2020 04:39:02 GMT<br><span class="hljs-attribute">Content-Type</span>: text/plain<br><span class="hljs-attribute">Content-Length</span>: 9<br><span class="hljs-attribute">Last-Modified</span>: Tue, 08 Dec 2020 04:38:58 GMT<br><span class="hljs-attribute">Connection</span>: keep-alive<br><span class="hljs-attribute">ETag</span>: &quot;5fcf0362-9&quot;<br><span class="hljs-attribute">Accept-Ranges</span>: bytes<br></code></pre></td></tr></table></figure>

<p>第一行 <code>HTTP/1.1 200 OK</code> 表示响应的协议是 <code>HTTP/1.1</code> 版本，状态码是 <code>200</code>，状态信息是 <code>OK</code>，这表示一个正确的响应。</p>
<p>针对于数据响应的处理，<code>XMLHttpRequest</code> 提供以下属性和方法：</p>
<ul>
<li><p><code>status</code> 只读属性：</p>
<p>表示响应的状态码，正常响应的状态码是 200，数据找不到时状态码是 404，常见的 404 页面就是使用此状态码。一般处理响应时，都是根据状态码是否是 200 而判断响应是否成功。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-comment">// 响应成功</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 其他情况</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>状态码并不是除了 200 都是错误，关于各个状态码对应的语义，可以 <a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-status-codes.html">查看这里</a>，在此不过多解释。</p>
</li>
<li><p><code>statusText</code> 只读属性：</p>
<p>描述响应状态的信息，它是人为设置的字符串，在数据包中，它紧跟在状态码后面，比如 <code>200 OK</code>，<code>404 Not Found</code>，其中 <code>OK</code> 和 <code>Not Found</code> 就是 <code>statusText</code>，这个值并不常用。</p>
</li>
<li><p><code>response</code> 只读属性：</p>
<p>响应的数据，它的数据格式变化多样，可能是二进制数据，字符串或者数字，需要针对不同的情况做不同的处理。</p>
</li>
<li><p><code>responseText</code> 只读属性：</p>
<p>响应数据的文本形式，如果你确信知道响应数据是可读文本，可以通过此项获取数据。</p>
</li>
<li><p><code>getResponseHeader</code> 方法：获取指定的响应头信息，传入头信息的名字，返回其值，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 当返回类型是 json 时，对其解析</span><br>  <span class="hljs-keyword">if</span> (xhr.getResponseHeader(<span class="hljs-string">&quot;content-type&quot;</span>) === <span class="hljs-string">&quot;application/json&quot;</span>) &#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.parse(xhr.response);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>获取头信息时，名字不区分大小写，<code>content-type</code> 和 <code>Content-Type</code> 一样。</p>
</li>
<li><p><code>getAllResponseHeaders()</code> 方法：获取能够读取的全部响应头信息，返回一段字符串，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> allHeaders = xhr.getAllResponseHeaders();<br><span class="hljs-built_in">console</span>.log(allHeaders);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p><code>XMLHttpRequest</code> 的事件继承自事件目标对象，所以也可以使用 <code>addEventListener</code> 来绑定事件，解除事件同样可以使用 <code>removeEventListener</code>，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><br>xhr.addEventListener(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;load&quot;</span>, xhr);<br>&#125;);<br>xhr.addEventListener(<span class="hljs-string">&quot;progress&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;progress&quot;</span>, xhr);<br>&#125;);<br>xhr.addEventListener(<span class="hljs-string">&quot;abort&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abort&quot;</span>, xhr);<br>&#125;);<br><br>xhr.send();<br></code></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-兼容性"><a href="#XMLHttpRequest-兼容性" class="headerlink" title="XMLHttpRequest 兼容性"></a>XMLHttpRequest 兼容性</h3><p><code>XMLHttpRequest</code> 兼容到 IE 9，如果需要在低版本 IE 中使用 AJAX，可以使用 IE 自带的 <code>ActiveXObject</code> 对象，但是它并不是很好用。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// IE8 及以下</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);<br><br>xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/data.txt&quot;</span>);<br>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(xhr.responseText);<br>  &#125;<br>&#125;;<br><br>xhr.send();<br></code></pre></td></tr></table></figure>

<p>上面的代码可以在 IE9 以下发送请求，写法和 <code>XMLHttpRequest</code> 有一定的出入，比如 <code>new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</code> 返回的对象就没有 <code>onload</code> 事件，只有 <code>onreadstatechange</code> 事件。</p>
<p><code>ActiveXObject</code> 和 <code>XMLHttpRequest</code> 并不兼容，你可以在【课程总结】中找到处理二者兼容的方案。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面简单介绍了 JavaScript 中 AJAX 的实现，其中涉及到很多网络知识，为了照顾零基础的同学，此章节对网络部分的剖析并不够深入，请大家见谅。我会在后续开设 web 网络的课程，对其详细的介绍。</p>
</div>
  <div class="article-ft">
    <p>
      <span class="last-update">最后更新时间：2021/01/04</span>
    </p>
  </div>
</article>
</main>
    <script>
      $(document).ready(function () {
        $("article table:not(.highlight table)").addClass("table table-hover");
      });
    </script>
  </body>
</html>
