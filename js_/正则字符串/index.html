<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="HTML，CSS，JavaScript 基础知识 " />
    
<link rel="stylesheet" href="/jnet-basic/css/layout.css">

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/tomorrow-night.css"
      integrity="sha256-qLi5v7wdKdn9AYLccUD3MLqpdfeMqy2ZU2vcImOS2xU="
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"
      integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"
    ></script>
    <title>JNet Basic</title>
  <meta name="generator" content="Hexo 5.2.0"></head>

  <body>
    <div class="sidebar">
  <aside class="sidebar-toc-page"><!--  -->


<div class="toc-page">
  <div class="toc-page-hd">
    <a href="/"> JNet Basic </a>
  </div>
  <ul>
    
<li>
  <a href="/jnet-basic/%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/" class="">课程介绍</a>
</li>

<li>
  <a href="/jnet-basic/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" class="">软件安装</a>
</li>

<li>
  <span class="label">html_</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/html_/%E6%95%99%E7%BA%B2/" class="">教纲</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E6%A6%82%E8%BF%B0/" class="">概述</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/" class="">基础理论</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%A4%B4%E9%83%A8%E5%AD%A6%E4%B9%A0/" class="">头部学习</a>
</li>

<li>
  <span class="label">元素学习</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E6%96%87%E7%AB%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%83%E7%B4%A0/" class="">文章相关的元素</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E8%B6%85%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%9B%BE%E7%89%87/" class="">超链接与图片</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E6%97%A0%E8%AF%AD%E4%B9%89%E5%85%83%E7%B4%A0/" class="">无语义元素</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E6%A0%BC/" class="">表格</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E5%85%83%E7%B4%A0%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0/" class="">表单元素</a>
</li>

</ul>

<li>
  <a href="/jnet-basic/html_/%E5%B1%9E%E6%80%A7/" class="">属性</a>
</li>

<li>
  <a href="/jnet-basic/html_/%E8%A1%A5%E5%85%85%E4%B8%8E%E7%BB%93%E6%9D%9F/" class="">补充与结束</a>
</li>

</ul>

<li>
  <span class="label">css_</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/css_/%E6%95%99%E7%BA%B2/" class="">教纲</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E6%A6%82%E8%BF%B0/" class="">概述</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E7%BC%96%E5%86%99_CSS/" class="">编写_CSS</a>
</li>

<li>
  <a href="/jnet-basic/css_/CSS_%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/" class="">CSS_引入方式</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E9%80%89%E6%8B%A9%E5%99%A8/" class="">选择器</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E5%B1%82%E5%8F%A0%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7/" class="">核心概念-层叠，继承，优先级</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%B5%81/" class="">盒模型与文档流</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/" class="">文本处理</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E8%A1%A8%E6%A0%BC%E5%A4%84%E7%90%86/" class="">表格处理</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E8%83%8C%E6%99%AF%E5%A4%84%E7%90%86/" class="">背景处理</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E6%9D%82%E9%A1%B9/" class="">杂项</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B1%80/" class="">基础布局</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E5%B8%83%E5%B1%80%E8%BF%9B%E9%98%B6/" class="">布局进阶</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E7%BB%83%E4%B9%A0/" class="">常见布局练习</a>
</li>

<li>
  <a href="/jnet-basic/css_/%E8%A1%A5%E5%85%85%E4%B8%8E%E7%BB%93%E6%9D%9F/" class="">补充与结束</a>
</li>

</ul>

<li>
  <span class="label">js_</span>
</li>
<ul>
  
<li>
  <a href="/jnet-basic/js_/%E7%9B%AE%E5%BD%95/" class="">目录</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E7%A8%8B%E5%BA%8F%E5%BC%95%E5%AF%BC%E8%AF%BE/" class="">程序引导课</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%9F%BA%E7%A1%80/" class="">基础</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%95%B0%E6%8D%AE%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="">数据、运算符和表达式</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%87%BD%E6%95%B0%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="">函数和作用域</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" class="">引用类型</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="">流程控制</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="">类型判断与类型转换</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/" class="">函数深入</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%B8%B8%E7%94%A8_API/" class="">常用_API</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="">异步编程</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%8F%90%E5%8D%87/" class="">提升</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E9%97%AD%E5%8C%85/" class="">闭包</a>
</li>

<li>
  <a href="/jnet-basic/js_/this_%E5%85%B3%E9%94%AE%E5%AD%97/" class="">this_关键字</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/" class="">对象原型</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="">面向对象</a>
</li>

<li>
  <a href="/jnet-basic/js_/DOM&BOM/" class="">DOM&BOM</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%8A%A0%E8%BD%BD/" class="">渲染与加载</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" class="">错误处理</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E5%86%85%E5%AD%98/" class="">内存</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/" class="">严格模式</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E6%AD%A3%E5%88%99%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="current">正则字符串</a>
</li>

<li>
  <a href="/jnet-basic/js_/%E7%BD%91%E7%BB%9C%E7%AE%80%E8%BF%B0/" class="">网络简述</a>
</li>

</ul>

<li>
  <a href="/jnet-basic/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/" class="">课程总结</a>
</li>

<li>
  <a href="/jnet-basic/%E7%B4%A0%E6%9D%90/" class="">素材</a>
</li>

  </ul>
</div>
</aside>
  <aside class="sidebar-toc-article"><div class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E-match-%E5%87%BD%E6%95%B0"><span class="toc-text">创建与 match 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-text">规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%8C%B9%E9%85%8D"><span class="toc-text">普通匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99%E5%AD%97%E7%AC%A6"><span class="toc-text">特殊规则字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F"><span class="toc-text">贪婪模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6"><span class="toc-text">模式修正符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RegExp"><span class="toc-text">RegExp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">字符串函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-text">性能与应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-text">性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a></li></ol></li></ol></div>
</aside>
</div>
<script>
  $(document).ready(function () {
    var elTocPage = $('.sidebar .sidebar-toc-page').get(0);
    $(elTocPage).on('click', function (elToc) {
      $(this).addClass('show')
    })
    $(document).on('click', function (el) {
      elTocPage.contains(el.target) || $(elTocPage).removeClass('show');
    })
  })
</script>
    <main><article>
  <h1>正则字符串</h1>
  <hr />
  <div class="article-bd"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>正则表达式是一段特殊规则的字符串，它可以在一个字符串中找出满足指定规则的字符串子集，在处理字符串时，正则表达式有非常强的能力。</p>
<p>比如处理一个日期字符串，我们需要分离其年月日，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> date = <span class="hljs-string">&quot;2000-01-02&quot;</span>;<br><span class="hljs-keyword">var</span> arr = date.split(<span class="hljs-string">&quot;-&quot;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;年&quot;</span>, arr[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;月&quot;</span>, arr[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;日&quot;</span>, arr[<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure>

<p>但是现在出现了新的情况，数据格式不严谨，数据可能是以下样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> dates = [<span class="hljs-string">&quot;2000-01-02&quot;</span>, <span class="hljs-string">&quot;2000/01/02&quot;</span>, <span class="hljs-string">&quot;2000.01.02&quot;</span>, <span class="hljs-string">&quot;2000-1-2&quot;</span>];<br></code></pre></td></tr></table></figure>

<p>此时针对不同类型的日期格式，我们需要使用不同的方式去分割，并且在此之前，我们可能还不知道它们具体是什么格式，此时，一个正则字符串解决上述所有问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> dates = [<span class="hljs-string">&quot;2000-01-02&quot;</span>, <span class="hljs-string">&quot;2000/01/02&quot;</span>, <span class="hljs-string">&quot;2000.01.02&quot;</span>, <span class="hljs-string">&quot;2000-1-2&quot;</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; dates.length; i++) &#123;<br>  <span class="hljs-keyword">var</span> m = dates[i].match(<span class="hljs-regexp">/^(\d&#123;4&#125;).(\d&#123;1,2&#125;).(\d&#123;1,2&#125;)$/</span>);<br>  <span class="hljs-keyword">if</span> (m !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;年&quot;</span>, m[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;月&quot;</span>, m[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;日&quot;</span>, m[<span class="hljs-number">3</span>]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，<code>/^(\d&#123;4&#125;).(\d?\d).(\d?\d)$/</code> 这一串火星文就是正则字符串，它指定了一个字符串规则，当字符串满足此规则，它会对其进行截取和分割。现在简单的了解下这段正则字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">/^(\d&#123;<span class="hljs-number">4</span>&#125;).(\d?\d).(\d?\d)$/;<br></code></pre></td></tr></table></figure>

<ul>
<li>首尾的反斜杠 <code>/</code> 是用来声明正则字符串，就类似普通字符串的单双引号。</li>
<li>开头的上尖号 <code>^</code> 指定字符串必须按照后续规则开头，也就是限制字符串的开头。</li>
<li><code>\d&#123;4&#125;</code> 表示四个连续的数字，这个规则对应了年。</li>
<li>圆括号包裹一组规则，表示这段规则记作一组。正则字符串会在查找后把每组规则内的字符串会依次分割出来，所以后续我们可以根据数组访问 <code>m[1]</code>、<code>m[2]</code> 和 <code>m[3]</code> ，对应了年月日三组数据。</li>
<li>小数点 <code>.</code> 表示任何字符，正好对应了我们日期分隔符的不同。</li>
<li><code>\d&#123;1,2&#125;</code> 表示连续 1 到 2 个数字，对应了日期的月日缺省前缀 0 的情况，比如 <code>dates</code> 的最后一个值。</li>
<li><code>$</code> 和上尖号 <code>^</code> 类似，表示了必须按照这个规则结尾，也就是限制字符串的结尾。</li>
</ul>
<p>把上面的话合并一下，这串正则表达式的意思就是：以 4 个数字开头，连接任意一个字符，连接一个或者两个数字，连接任意一个字符，连接一个或者两个数字结尾的字符串。</p>
<p>实际上正则表达式真的真的很简单，希望大家学习本课程千万不要有负担，不要被如火星文一般的表示方式迷惑，只要学习完正则的语法，<strong>它完全是可读的</strong>。</p>
<p><strong>eg：大部分程序语言的正则字符串都是统一参照 PCRE 标准，JS 中也是，所以你学习完正则字符串后，以后也可以在其他语言使用。如果你已经学习过 PCRE 标准的正则，那么可以直接跳过使用章节。</strong></p>
<p>eg：为了简化，正则字符串后面简化为正则。</p>
<h2 id="创建与-match-函数"><a href="#创建与-match-函数" class="headerlink" title="创建与 match 函数"></a>创建与 match 函数</h2><p>正则的创建有两种方式：</p>
<ul>
<li>字面量创建：使用反斜杠直接包裹</li>
<li>构造函数创建：使用 <code>RegExp</code> 构造函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/12345/</span>;<br><span class="hljs-keyword">var</span> reg2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;12345&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>上面两种方式都可以创建正则，第一种是字面量创建，第二种是函数创建，<code>RegExp</code> 函数接受一个普通字符串当做正则的规则。从第二种方式可以看出，正则在 JS 中是引用类型，它不是字符串类型。</p>
<p>每个字符串都可以使用 <code>match</code> 函数来根据正则查找，<code>match</code> 函数存在于 <code>String.prototype</code> 上。它的使用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&quot;abc 123 ABC&quot;</span>.match(<span class="hljs-regexp">/123/</span>);<br><span class="hljs-built_in">console</span>.log(m);<br></code></pre></td></tr></table></figure>

<p><code>match</code> 函数会根据正则查找字符串，然后返回查找结果，如果不成功，返回一个 <code>null</code>。</p>
<p><strong>eg：在正则中，把查找的过程称作匹配，后续介绍中，都会使用匹配一词代替查找。</strong></p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="普通匹配"><a href="#普通匹配" class="headerlink" title="普通匹配"></a>普通匹配</h3><p>普通匹配就如同查找字符串，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&quot;abc 123 ABC&quot;</span>;<br><span class="hljs-keyword">var</span> m = foo.match(<span class="hljs-regexp">/123/</span>);<br><span class="hljs-built_in">console</span>.log(m);<br></code></pre></td></tr></table></figure>

<p>正则 <code>/123/</code> 的规则是字符串 ‘<code>123</code>‘，上面代码中，会在 <code>foo</code> 字符串中查找字符串 ‘<code>123</code>‘，如果匹配成功，返回匹配的字符串。</p>
<p>大部分字符在正则中都没规则意义，它们用于指定匹配的内容，比如数字，大小写字母，汉字等。</p>
<h3 id="特殊规则字符"><a href="#特殊规则字符" class="headerlink" title="特殊规则字符"></a>特殊规则字符</h3><p>在正则中，一部分字符或者转义字符具有特殊的意义，它们表示一定的规则，以下是常用具有规则意义的字符：</p>
<table>
<thead>
<tr>
<th>规则字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>匹配字符串的开头，用以决定字符串由什么规则开始，比如 <code>/^abc/</code>，可以匹配 <code>abcdefe</code>，但是不能匹配 <code>1abcd</code>。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配字符串的结尾，用以决定字符串由什么规则结束，比如 <code>/abc$/</code>，可以匹配 <code>123abc</code>，但不能匹配 <code>abcd</code>。当它和 <code>^</code> 配合使用时，就限制了整个字符串的开头的结尾。</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配任何字符，比如 <code>/a.c/</code> 就可以匹配到 <code>123aac</code>，中的 <code>aac</code>，或者匹配到 <code>a_b456</code> 中的 <code>a_b</code>。</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配前一个规则 0 次或多次，比如 <code>/a*b/</code> 可以匹配字符串中的 <code>b</code>、<code>ab</code>、<code>aaaab</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前一个规则 1 次或多次，比如 <code>/a+b/</code> 可以匹配字符串中的 <code>ab</code>、<code>aaaaaab</code>，但是不能匹配到 <code>b</code>，因为 <code>b</code> 中没有出现 <code>a</code> 字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前一个规则 0 次或 1 次，比如 <code>/a?b/</code> 可以匹配字符串中的 <code>b</code> 和 <code>ab</code>，但不能匹配到 <code>abb</code></td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配一个数字，比如 <code>/1\d\d/</code> 可以匹配字符串中的 <code>123</code>、<code>100</code>，例如在 <code>ab19876</code> 中，可以匹配到 <code>198</code> 三个数字。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配一个非数字，比如 <code>/\D\d/</code> 可以匹配字符串中的 <code>h1</code>、<code>h2</code>、<code>c0</code>，例如在 <code>123@123.com</code> 中，可以匹配到 <code>@1</code> 这两个字符。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配一个空白符，比如换行空格【tab】制表符，比如 <code>/abc\s/</code> 可以匹配 <code>abc abc!</code> 中的 <code>abc </code>，而不能匹配 <code>abc!</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配一个非空白符，比如 <code>/abc\S/</code> 可以匹配 <code>abc abc!</code> 中的 <code>abc!</code>。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配大小写字母数字和下划线，比如 <code>/abc\w123/</code> 可以匹配字符串中的 <code>abc_123</code>、<code>abcA123</code>，但是不能匹配<code>abc@123</code>、<code>abc!123</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配大小写字母数字和下划线之外的字符，比如 <code>/abc\w123/</code> 可以匹配字符串中的 <code>abc@123</code>、<code>abc!123</code>。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配换行符。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配回车符。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配水平制表符。</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符，可以把特殊字符转义为普通字符，比如需要匹配 JS 的文件，可以使用 <code>/.+\.js$/</code>，它会匹配如 <code>app.js</code>、<code>pro.js</code> 等字符串。同理，<code>\^$*+?&#123;&#125;[]</code> 等字符也可以使用正斜杠转义。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配单词边界，比如 <code>/\bpen\b/</code> 只能能够单词 <code>pen</code>，例如 <code>a pen,a box</code> 中可以匹配 <code>pen</code>，<code>pen</code> 的左边是空格，右边是逗号，一般很难处理，但是使用 <code>\b</code> 就可以很容易匹配。</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>匹配前一个规则 n 次，比如 <code>/fo&#123;2&#125;/</code> 可以匹配字符串中的 <code>foo</code>，例如在 <code>bars foos</code> 中，<code>foo</code> 将会被匹配。</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>匹配前一个规则多次，但是至少 n 次，比如 <code>/fo&#123;2,&#125;/</code> 可以匹配 <code>foo</code>、<code>fooo</code>、<code>fooooo</code>，其中字符 <code>o</code> 不能匹配 <code>2</code> 次以下。</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>匹配前一个规则 n 到 m 次，比如 <code>/fo&#123;2,3&#125;/</code> 就只能匹配 <code>foo</code>、与 <code>fooo</code></td>
</tr>
<tr>
<td><code>x|y</code></td>
<td>匹配规则 x 或者规则 y，比如 <code>/1a|b1/</code> 可以匹配 <code>1a1</code> 或者 <code>1b1</code>。</td>
</tr>
<tr>
<td><code>[xyz]</code></td>
<td>一个规则集合，匹配其中的任意规则，比如：<code>/1[abc]1/</code> 可以匹配 <code>1a1</code>、<code>1b1</code>、<code>1c1</code>。在规则集合中，可以使用扩折号来指定字母或者数字范围，比如 <code>/[a-z0-9A-Z_]/</code> 就等同于 <code>/\w/</code></td>
</tr>
<tr>
<td><code>[^xyz]</code></td>
<td>匹配一个规则集合的补集，比如：<code>/1[^abc]1/</code> 可以匹配 <code>1!1</code>、<code>1@1</code>，但是不能匹配 <code>1a1</code>。</td>
</tr>
<tr>
<td><code>(x)</code></td>
<td>匹配一个模式，可以理解成一个规则组。比如 <code>/(ab)&#123;2&#125;/</code> 可以匹配 <code>abab</code>，如果不使用圆括号，<code>&#123;&#125;</code> 只能修饰前一个字符 <code>b</code>，而不是 <code>ab</code>。模式可以配合其他特殊字符使用，比如 <code>/(fo*)&#123;3&#125;/</code> 可以匹配 <code>fff</code>、<code>foffoo</code>，<code>foofooofoooo</code>。</td>
</tr>
<tr>
<td><code>\数字</code></td>
<td>匹配一个模式的结果，数字指定了匹配哪一个模式，比如 <code>/(\d)a\1/</code> 中，<code>\1</code>表示匹配第一个模式的结果，其中第一个模式就是 <code>(\d)</code>，所以 <code>/(\d)a\1/</code> 可以匹配诸如 <code>1a1</code>，<code>9a9</code> 这样的字符串，但是不能匹配 <code>1a2</code>、<code>2a7</code>，因为 <code>\1</code> 匹配的是模式的结果，不是模式的规则。</td>
</tr>
<tr>
<td><code>(?:x)</code></td>
<td>匹配一个模式，但是不记录该模式，比如 <code>/(?:foo)(bar) \1/</code> 中， <code>\1</code> 找到的第一个模式将会是 <code>(bar)</code>，而不是 <code>(?:foo)</code>，<code>(?:foo)</code> 的作用和 <code>(foo)</code> 一样，但是它不被记录。</td>
</tr>
<tr>
<td><code>x(?=y)</code></td>
<td>匹配规则 x，但是需要规则 xy 成立。比如 <code>/foo(?=bar)/</code>，对于字符串 <code>foo foobar</code>，它会匹配第二个 <code>foo</code>，因为 <code>foo</code> 后必须要有 <code>bar</code> 字符串。</td>
</tr>
<tr>
<td><code>(?&lt;=y)x</code></td>
<td>匹配规则 x，但是需要规则 yx 成立。比如 <code>/(?&lt;=foo)bar/</code>，对于字符串 <code>bar foobar</code>，它只会匹配第二个 <code>bar</code>，因为 <code>bar</code> 前面必须要有 <code>foo</code> 字符串。</td>
</tr>
<tr>
<td><code>x(?!y)</code></td>
<td>匹配规则 x，但是需要规则 xy 不成立。比如 <code>/foo(?!bar)/</code>，对于字符串 <code>foobar foo</code>，他只会匹配第二个 <code>foo</code>，因为 <code>foo</code> 后面不能有 <code>bar</code> 字符串。</td>
</tr>
<tr>
<td><code>(?&lt;!y)x</code></td>
<td>匹配规则 x，但是需要规则 yx 不成立。写烦了不写例子了，前三个规则和这个规则使用并不频繁，需要使用的时候查表即可。</td>
</tr>
</tbody></table>
<p>以上是大部分正则中的特殊字符，使用较频繁。但是还没有列举完全，部分特殊字符使用非常少，可以 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">点此查表</a>。</p>
<h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>默认情况下，JS 中的正则匹配是贪婪模式，贪婪模式会尽可能多的匹配字符串。在使用 <code>*</code>、<code>+</code>、<code>&#123;n,&#125;</code> 时，它们会尽可能多的匹配，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-string">&quot;foo 123 foo abc foo zzz foo&quot;</span>.match(<span class="hljs-regexp">/foo.*foo/</span>);<br><span class="hljs-built_in">console</span>.log(re);<br></code></pre></td></tr></table></figure>

<p>匹配的结果是整个字符串，从开头的 <code>foo</code> 到结尾的 <code>foo</code> 中间，都会被 <code>.*</code> 匹配。这种情况的匹配，称作贪婪模式。</p>
<p><strong>可以在 <code>*</code>、<code>+</code>、<code>&#123;n,&#125;</code> 后面使用 <code>?</code> 来解除贪婪模式，让其匹配最短字符串</strong>，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-string">&quot;foo 123 foo abc foo zzz foo&quot;</span>.match(<span class="hljs-regexp">/foo.*?foo/</span>);<br><span class="hljs-built_in">console</span>.log(re);<br></code></pre></td></tr></table></figure>

<p>上面的正则只会匹配 <code>foo 123 foo</code>，然后就停止匹配。</p>
<h3 id="模式修正符"><a href="#模式修正符" class="headerlink" title="模式修正符"></a>模式修正符</h3><p>正则匹配时，还区分大小写，匹配成功的时候也会停止匹配，这些规则是可以调整的，使用讴歌 <strong>模式修正符</strong> 可以修改正则的匹配模式，模式修正符被放到正则的末尾，反斜杠 <code>/</code>的后面。</p>
<p>JS 中有常用模式修正符如下：</p>
<table>
<thead>
<tr>
<th>修正符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>g</code></td>
<td>全局匹配，不会在匹配成功后停止匹配。</td>
</tr>
<tr>
<td><code>i</code></td>
<td>忽略大小写，比如 <code>/abc/i</code> 此时可以匹配到 <code>ABC</code>、<code>Abc</code>、<code>aBC</code> 等。</td>
</tr>
<tr>
<td><code>m</code></td>
<td>多行匹配，配合 <code>^</code> 和 <code>$</code> 使用，可以匹配任何一行的开头和结尾。比如 <code>/^bar/</code> 不能匹配 <code>foo\nbar</code> 中的 <code>bar</code> 字符串，但是 <code>/^bar/m</code> 就可以匹配，因为 <code>\n</code> 换行了，<code>bar</code> 字符串是第二行的开头。</td>
</tr>
<tr>
<td><code>s</code></td>
<td>让 <code>.</code> 可以匹配换行符，默认情况下 <code>/.*/</code> 只能匹配 <code>foo\nbar</code> 的 <code>foo</code>，不匹配换行符，但是 <code>/.*/s</code> 就可匹配整个字符串 <code>foo\nbar</code>。</td>
</tr>
</tbody></table>
<p>如果使用 <code>RegExp</code> 创建正则，模式修正符放在第二个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;.*&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>);<br><span class="hljs-keyword">var</span> re = <span class="hljs-string">&quot;foo\nbar&quot;</span>.match(reg);<br></code></pre></td></tr></table></figure>

<p>模式修正符还有两个，它们可能并不常有或者是新标准的规定，我不会对其介绍，如果你非常非常有兴趣，可以看看：</p>
<table>
<thead>
<tr>
<th>修正符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>u</code></td>
<td>是否开启 Unicode 模式匹配。Unicode 是一种字符集，开启此模式可以按一定模式匹配 Unicode 字符。比如中文 ‘<code>是</code>‘ 的 Unicode 编码是 <code>662f</code>，当我们匹配中文 ‘<code>是</code>‘ 这个字的时候，可以使用 <code>&#39;是&#39;.match(/\u&#123;662f&#125;/u)</code> 来匹配，可以匹配到中文 ‘<code>是</code>‘ 这个字。<br />如果不开启 Unicode 模式，代码 <code>&#39;是&#39;.match(/\u&#123;662f&#125;/)</code> 会得到一个 <code>null</code>，<code>\u&#123;xxxx&#125;</code> 这种写法不生效。一般情况下，很少使用这种写法，因为 ： <br />- <code>&#39;是&#39;.match(/\u662f/)</code><br />- <code>&#39;是&#39;.match(/是/)</code><br/>- <code>&#39;\u662f&#39;.match(/是/)</code><br />- <code>&#39;\u662f&#39;.match(/\u662f/)</code><br/>四种写法都可以匹配中文的 ‘<code>是</code>‘ 字</td>
</tr>
<tr>
<td><code>y</code></td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky">点击这里</a></td>
</tr>
</tbody></table>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>在 JS 中，正则是引用类型，它们由 <code>RegExp</code> 构造而来，创建一个正则有以下方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg1 = <span class="hljs-regexp">/foo/i</span>;<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">var</span> reg2 = <span class="hljs-keyword">new</span> Regexp(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>);<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">var</span> reg2 = <span class="hljs-keyword">new</span> Regexp(<span class="hljs-regexp">/foo/</span>, <span class="hljs-string">&quot;i&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><code>RegExp</code> 有两个常用的函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>exec</code></td>
<td>匹配一段字符串，匹配成功返回正则匹配结果，失败返回 <code>null</code>。类似字符串的 <code>match</code> 函数</td>
</tr>
<tr>
<td><code>test</code></td>
<td>匹配一段字符串，是返回 <code>true</code>，反之 <code>false</code>。</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\w+@\w+\./</span>;<br><span class="hljs-keyword">var</span> htmlStr = <span class="hljs-string">&quot;&lt;p&gt; &lt;span&gt;hello&lt;/span&gt; &lt;/p&gt;&quot;</span>;<br><span class="hljs-built_in">console</span>.log(reg.exec(htmlStr));<br><span class="hljs-built_in">console</span>.log(reg.test(htmlStr));<br></code></pre></td></tr></table></figure>

<p>其中 <code>exec</code> 函数在匹配成功时，返回的对象是一个数组，它的下标和属性对应以下结果：</p>
<table>
<thead>
<tr>
<th>下标或属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td>匹配的字符串</td>
</tr>
<tr>
<td><code>1~n</code></td>
<td>各个模式中匹配的字符串</td>
</tr>
<tr>
<td><code>index</code></td>
<td>匹配字符串的下标</td>
</tr>
<tr>
<td><code>input</code></td>
<td>原始字符串</td>
</tr>
</tbody></table>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>字符串的一部分函数比如查找，替换等，也支持正则字符串：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>match</code></td>
<td>匹配一个正则，成功返回匹配结果，失败返回 <code>null</code>。当设置全局匹配时，<code>match</code> 只会得到一个包含所有匹配到的字符串的数组。</td>
</tr>
<tr>
<td><code>matchAll</code></td>
<td>匹配一个含有全局匹配的正则，返回一个迭代对象。成功或者失败都会返回一个迭代对象。（迭代对象属于新标准中的知识，再次不多介绍）</td>
</tr>
<tr>
<td><code>search</code></td>
<td>按照正则查找字符串，函数功能不变。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td>按照规则替换字符串，函数功能不变。</td>
</tr>
<tr>
<td><code>split</code></td>
<td>按照规则分割字符串，函数功能不变。</td>
</tr>
</tbody></table>
<p>演示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;foobarfoobarfoobar&quot;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(oo)../g</span>;<br><br><span class="hljs-built_in">console</span>.log(str.match(<span class="hljs-regexp">/(oo)../g</span>));<br><br><span class="hljs-comment">// 迭代对象可以使用 for of 遍历，for of 也是新标准中的语法，本系列课程不介绍</span><br><span class="hljs-keyword">var</span> mAll = str.matchAll(reg);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">of</span> mAll) &#123;<br>  <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(str.search(reg));<br><span class="hljs-built_in">console</span>.log(str.replace(reg, <span class="hljs-string">&quot; replace &quot;</span>));<br><span class="hljs-built_in">console</span>.log(str.split(reg));<br></code></pre></td></tr></table></figure>

<h2 id="性能与应用"><a href="#性能与应用" class="headerlink" title="性能与应用"></a>性能与应用</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>使用正则字符串实际上非常耗费性能，在一对多的服务中，很少使用正则，比如服务器，大量正则的使用是给计算机带来很大负担。但是 JS 是客户端语言，负担会小很多。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>正则一般都是用来处理有一定规则的文本，比如日期，邮箱，网址，手机号等等，使用正则分解这些文本会变得异常简单，比如本页最开始的段落，我们处理日期一样。</p>
<p>尝试编写一个匹配邮箱的正则：邮箱的规则一般分为两部分，<code>@</code> 符前面表示账户，<code>@</code> 符后表示邮箱的服务商，比如 QQ 邮箱就是 <a href="mailto:&#120;&#120;&#120;&#x78;&#x78;&#64;&#113;&#113;&#46;&#99;&#x6f;&#109;">&#120;&#120;&#120;&#x78;&#x78;&#64;&#113;&#113;&#46;&#99;&#x6f;&#109;</a>，其中账户或者服务商一般都由数字字符下划线和扩折号 <code>-</code> 组成，服务商一般是一个域名，域名至少由两个单词组成，中间用点连接。所以一个邮箱的规则可以写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> emailReg = <span class="hljs-regexp">/[\w-]+@[\w-]+(\.[\w-])/</span>;<br>emailReg.test(<span class="hljs-string">&quot;123456@163.com&quot;</span>); <span class="hljs-comment">//true</span><br>emailReg.test(<span class="hljs-string">&quot;123456@gmail.com&quot;</span>); <span class="hljs-comment">// true</span><br>emailReg.test(<span class="hljs-string">&quot;123456@qq.com&quot;</span>); <span class="hljs-comment">// true</span><br>emailReg.test(<span class="hljs-string">&quot;123456@mail.com.cn&quot;</span>); <span class="hljs-comment">// true</span><br>emailReg.test(<span class="hljs-string">&quot;@main.com&quot;</span>); <span class="hljs-comment">// false</span><br>emailReg.test(<span class="hljs-string">&quot;123456@com&quot;</span>); <span class="hljs-comment">// false</span><br>emailReg.test(<span class="hljs-string">&quot;123456mail.com&quot;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>如果你的项目有验证邮箱的需要，那么可以根据上述方式来判断表单是否提交，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>申请账号需要一个邮箱<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mail&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mail&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>确定<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> emailReg = <span class="hljs-regexp">/[\w-]+@[\w-]+(\.[\w-])/</span>;</span><br><br><span class="javascript">  <span class="hljs-keyword">var</span> formEl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;form&quot;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> inputEl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;mail&quot;</span>);</span><br><br><span class="javascript">  formEl.addEventListener(<span class="hljs-string">&quot;submit&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (emailReg.test(inputEl.value)) &#123;</span><br><span class="javascript">      <span class="hljs-comment">// 提交表单</span></span><br><span class="javascript">      alert(<span class="hljs-string">&quot;验证成功，即将提交。&quot;</span>);</span><br><span class="javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">      alert(<span class="hljs-string">&quot;邮箱格式不正确，请重新输入。&quot;</span>);</span><br>      e.preventDefault();<br>    &#125;<br>  &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</div>
  <div class="article-ft">
    <p>
      <span class="last-update">最后更新时间：2020/12/06</span>
    </p>
  </div>
</article>
</main>
    <script>
      $(document).ready(function () {
        $("article table:not(.highlight table)").addClass("table table-hover");
        $("article blockquote").addClass("blockquote");
      });
    </script>
  </body>
</html>
